                         1     ^Z80^
                         2     
                         3     NAME ^Rev 06.1 - TF^
                         4     
                         5     ;    Project:  EOS 6 Absolute Listing
                         6     ;
                         7     ;     ***********************************************************
                         8     ;     ****                                                   ****
                         9     ;     ****   EOS ABSOLUTE LISTING                            ****
                         10    ;     ****                                                   ****
                         11    ;     ****  Electronic Development Group                     ****
                         12    ;     ****              Coleco Industries Inc.               ****
                         13    ;     ****               999 Quaker Lane South               ****
                         14    ;     ****               West Hardford, Connecticut          ****
                         15    ;     ****                                  06110            ****
                         16    ;     ****                                                   ****
                         17    ;     ***********************************************************
                         18    ;
                         19    ;      This absolute listing was generated to ease software
                         20    ;      development on ADAM.   This listing provides the location
                         21    ;      of both released and unreleased entry points.  Released
                         22    ;      entry points begin immediately in this file with the  jump
                         23    ;      table and end before the first code segment listed.
                         24    ;      Released entry points include the jump table, common  data
                         25    ;      areas(EOSCOMN),  common data tables, and equates which
                         26    ;      describe the released data structures.  Direct access
                         27    ;      to code segments is STRONGLY DISCOURAGED and may make
                         28    ;      your application incompatable with some ADAMs.  there  is
                         29    ;      more than one version of EOS on the market at this  time
                         30    ;      and updates are planned.
                         31    ;
                         32    ;      For further information on ADAM or EOS consult the
                         33    ;      ADAM Technical Reference Manual or send your questions
                         34    ;      in writing to:
                         35    ;
                         36    ;                       Coleco Software Suppot
                         37    ;
                         38    ;      at the above address.
                         39    ;
                         40    ;  COLECO MAKES NO REPRESENTATIONS OR WARRANTIES WHATSOEVER,  INCLUDING
                         41    ;  WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR MERCHANTABILITY  AND
                         42    ;  FITNESS FOR A PARTICULAR PURPOSE, IN CONNECTION WITH THE  MATERIALS
                         43    ;  CONTAINED HEREIN, AND SUCH MATERIALS ARE DISCLOSED AS IS.   COLECO
                         44    ;  SHALL HAVE NO LIABILITY FOR ANY LOSSES CAUSED TO RECIPIENTS  OF THESE
                         45    ;  MATERIALS BY REASON OF ANY CHANGES OR MODIFICATIONS MADE  BY COLECO  IN
                         46    ;  THESE MATERIALS AFTER THEIR DISCLOSURE HEREIN.  IN ADDITION,  COLECO
                         47    ;  SHALL HAVE NO LIABILITY FOR ANY CONSEQUENTIAL, SPECIAL, INDIRECT  OR
                         48    ;  INCIDENTAL DAMAGES OR LOSSES WHATSOEVER, INCLUDING LOSS OF  PROFITS,  IN
                         49    ;  CONNECTION WITH THE USE OF THE MATERIALS DISCLOSED HEREIN.
                         50    ;
                         51    ;*********************************************************************************
                         52    ;
                         53    ;       Rev History
                         54    ;       Rev.  Date        Name       Change
                         55    ;        6.1  21jun0844   af        Merge sources for absolute listing.
                         56    ;                                   No changes made to code.
                         57    ;        6.0  08oct 1545   jlk      Code released for production.
                         58    ;
                         59    ;[    code commented out by ¢;@***’was removed before EOS  ]
                         60    ;[ was grouped into one file, code commented out by simple ]
                         61    ;[ ';' was removed in the process of grouping E0S in order ]
                         62    ;[ to avoid assembier complaints  or LOCAL/GLOBAL conflicts]
                         63    ;[    @;********...’ generates code segments which were    ]
                         64    ;[ originally in separate files                            ]
                         65    ;*********************************************************************************
                         66    ;*********************************************************************************
                         67    ;*********************************************************************************
                         68    ;
                         69    NAME ^Rev 11 - RPD^
                         70    ;
                         71    ; Rev  Date          Made by    Change
                         72    ;  11   1Soct425p     RPD        changed E0S_4 to CV_A
                         73    ;  10   13oct1000p    RPD        made only OS7 jump entries conditionally assembled
                         74    ;   9   12oct2300     vsb        Added __POSIT_FILE,  __FILE_QUERY plus EOS1 thru EOS4
                         75    ;   8   07oct1710     rfj        __EFXOVER changed to _EFFECT _0VER
                         76    ;                                Added _UPDATE_SPINNER
                         77    ;   7   05oct1725     rtj        Renamed WRSPR_NM_TBL  to WR_SPR_ATTRIBUTE
                         78    ;   6   03oct1207     rtj        Increased TEMP_STACK to  12bytes,
                         79    ;                                Removed SAVED_COUNT
                         80    ;   &   30sept825p    RPD        replaced CONSOUT  data area with new CONSOUT2
                         81    ;   4   29sept235p    RPD        replaced PLAYSONGS  with SOUNDS
                         82    ;   3   26sept1005a   RPD        added conditional assembly stuff for super  games
                         83    ;   2   25sept850a    RPD        merged all of EOS ram together into this file
                         84    ;   1   20sept1005a   RPD        new memory mapping
                         85    ;   0   mid-sept      VB         original map @  E8000H
                         86    ;
                         87    TRUE                 EQU   0FFFFH                         
                         88    FALSE                EQU   00000H                         
                         89    
                         90    IN_EOS               EQU   TRUE                           
                         91    SUPERGAME            EQU   FALSE                          
                         92    ;
                         93    ; CURRENT EOS MEMORY MAPPING
                         94    ;
                         95    ;FCB_S         EQU     0D390H                  ;FCB area
                         96    ;THREE1K_BLKS  EQU     00400H                  ;3 FCB 1K buffers
                         97    EOS_CODE             EQU   0E000H                         ;address of EOS code segment
                         98    EOS_GLB_TBL          EQU   0FBFFH                         ;address of EOS global tables
                         99    EOS_JMP_TBL          EQU   0FC30H                         ;address of EOS jump table
                         100   EOS_GLB_RAM          EQU   0FD60H                         ;address of EOS global data  area
                         101   EOS_PCB_DCB          EQU   0FEC0H                         ;address of EOS PCB/DCB areas
                         102   
                         103   ;
                         104   ;  These are key record sizes, used  invarious EOS routines.
                         105   ;  See “INCLUDE FMGR_EQUS" AND “INCLUDE P_DCB_EQU" for details.
                         106   ;
                         107   
                         108   DIR_ENT_LENGTH       DEFL  26                             
                         109   P_SIZE               DEFL  4                              ;THE NUMBER OF BYTES IN THE PCB
                         110   D_SIZE               DEFL  21                             ;THE NUMBER OF BYTES  INTHE DCB
                         111   ;
                         112   ;
                         113   ;
                         114   ;  jump table area
                         115   ;
                         116   ; *********************************************************
                         117   
                         118                        ORG   EOS_JMP_TBL                    
                         119   
                         120   ; *********************************************************
                         121   
                         122   _EOS_START           EQU   $                              
                         123                        JP    __EOS_START                    
                         124   _CONS_DISP           EQU   $                              
                         125                        JP    __CONS_DISP                    
                         126   _CONS_INIT           EQU   $                              
                         127                        JP    __CONS_INIT                    
                         128   _CONS_OUT            EQU   $                              
                         129                        JP    __CONS_OUT                     
                         130   _DLY_AFT_HRD_RES     EQU   $                              
                         131                        JP    __DLY_AFT_HRD_RES              
                         132   _END_PR_BUFF         EQU   $                              
                         133                        JP    __END_PR_BUFF                  
                         134   _END_PR_CH           EQU   $                              
                         135                        JP    __END_PR_CH                    
                         136   _END_RD_1_BLOCK      EQU   $                              
                         137                        JP    __END_RD_1_BLOCK               
                         138   _END_RD_CH_DEV       EQU   $                              
                         139                        JP    __END_RD_CH_DEV                
                         140   _END_RD_KBD          EQU   $                              
                         141                        JP    __END_RD_KBD                   
                         142   _END_WR_1_BLOCK      EQU   $                              
                         143                        JP    __END_WR_1 BLOCK               
                         144   _END_WR_CH_DEV       EQU   $                              
                         145                        JP    __END_WR_CH_DEV                
                         146   _FIND_DCB            EQU   $                              
                         147                        JP    __FIND_DCB                     
                         148   _GET_DCB_ADDR        EQU   $                              
                         149                        JP    __GET_DCB_ADDR                 
                         150   _GET_PCB_ADDR        EQU   $                              
                         151                        JP    __GET_PCB_ADDR                 
                         152   _HARD_INIT           EQU   $                              
                         153                        JP    __HARD_INIT                    
                         154   _HARD_RESET_NET      EQU   $                              
                         155                        JP    __HARD_RESET_NET               
                         156   _PR_BUFF             EQU   $                              
                         157                        JP    __PR_BUFF                      
                         158   _PR_CH               EQU   $                              
                         159                        JP    __PR_CH                        
                         160   _RD_1_BLOCK          EQU   $                              
                         161                        JP    __RD_1_BLOCK                   
                         162   _RD_KBD              EQU   $                              
                         163                        JP    __RD_KBD                       
                         164   _RD_KBD_RET_CODE     EQU   $                              
                         165                        JP    __RD_KBD_RET_CODE              
                         166   _RD_PR_RET_CODE      EQU   $                              
                         167                        JP    __RD_PR_RET_CODE               
                         168   _RD_RET_CODE         EQU   $                              
                         169                        JP    __RD_RET_CODE                  
                         170   _RD_TAPE_RET_CODE    EQU   $                              
                         171                        JP    __RD_TAPERET  CODE             
                         172   _RELOC_PCB           EQU   $                              
                         173                        JP    __RELOC_PCB                    
                         174   _REQUEST_STATUS      EQU   $                              
                         175                        JP    __REQUEST_STATUS               
                         176   _REQ_KBO_STAT        EQU   $                              
                         177                        JP    __REQ_KBD_STAT                 
                         178   _REQ_PR_STAT         EQU   $                              
                         179                        JP    __REQ_PR_STAT                  
                         180   _REQ_TAPE_STAT       EQU   $                              
                         181                        JP    __REQ_TAPE STAT                
                         182   _SCAN_ACTIVE         EQU   $                              
                         183                        JP    __SCAN_ACTIVE                  
                         184   _SOFT_INIT           EQU   $                              
                         185                        JP    __SOFT_INIT                    
                         186   _SOFT_RES_DEV        EQU   $                              
                         187                        JP    __SOFT_RES_DEV                 
                         188   _SOFT_RES_KBD        EQU   $                              
                         189                        JP    __SOFT_RES_KBD                 
                         190   _SOFT_RES_PR         EQU   $                              
                         191                        JP    __SOFT_RES_PR                  
                         192   _SOFT_RES_TAPE       EQU   $                              
                         193                        JP    __SOFT_RES_TAPE                
                         194   _START_PR_BUFF       EQU   $                              
                         195                        JP    __START_PR_BUFF                
                         196   _START_PR_CH         EQU   $                              
                         197                        JP    __START_PR_CH                  
                         198   _START_RD_1_BLOCK    EQU   $                              
                         199                        JP    __START_RD_1 BLOCK             
                         200   _START_RD_CH_DEV     EQU   $                              
                         201                        JP    __START_RD_CH_DEV              
                         202   _START_RD_KBD        EQU   $                              
                         203                        JP    __START_RD_KBD                 
                         204   _START_WR_1_BLOCK    EQU   $                              
                         205                        JP    __START_WR_1 BLOCK             
                         206   _START_WR_CHDEV      EQU   $                              
                         207                        JP    __START_WR_CH DEV              
                         208   _SYNC                EQU   $                              
                         209                        JP    __SYNC                         
                         210   _WR_1_BLOCK          EQU   $                              
                         211                        JP    __WR_1_BLOCK                   
                         212   _WR_CH_DEV           EQU   $                              
                         213                        JP    __WR_CH_DEV                    
                         214   
                         215   ;
                         216   ;FILE  MANAGER    ENTRIES
                         217   ;
                         218   _FMGR_INIT           EQU   $                              
                         219                        JP    __FMGR_INIT                    
                         220   _INIT_TAPE_DIR       EQU   $                              
                         221                        JP    __INIT_TAPE_DIR                
                         222   _OPEN_FILE           EQU   $                              
                         223                        JP    __ OPEN FILE                   
                         224   _CLOSE_FILE          EQU   $                              
                         225                        JP    __CLOSE_FILE                   
                         226   _RESET_FILE          EQU   $                              
                         227                        JP    __RESET_FILE                   
                         228   _MAKE_FILE           EQU   $                              
                         229                        JP    __MAKE_FILE                    
                         230   _QUERY_FILE          EQU   $                              
                         231                        JP    __QUERY_FILE                   
                         232   _SET_FILE            EQU   $                              
                         233                        JP    __SET_FILE                     
                         234   _READ_FILE           EQU   $                              
                         235                        JP    __READ_FILE                    
                         236   _WRITE_FILE          EQU   $                              
                         237                        JP    __WRITE_FILE                   
                         238   _SET_DATE            EQU   $                              
                         239                        JP    __SET_DATE                     
                         240   _GET_DATE            EQU   $                              
                         241                        JP    __GET_DATE                     
                         242   _RENAME_FILE         EQU   $                              
                         243                        JP    __RENAME_FILE                  
                         244   _DELETE_FILE         EQU   $                              
                         245                        JP    __DELETE_FILE                  
                         246   _RD_DEV_DEP_STAT     EQU   $                              
                         247                        JP    __RD_DEV_DEP_STAT              
                         248   _GOTO_WP             EQU   $                              
                         249                        JP    __GOTO_WP                      
                         250   _READ_EOS            EQU   $                              
                         251                        JP    __READ_EOS                     
                         252   _TRIM_FILE           EQU   $                              
                         253                        JP    __TRIM_FILE                    
                         254   _CHECK_FCB           EQU   $                              
                         255                        JP    __CHECK_FCB                    
                         256   _READ_BLOCK          EQU   $                              
                         257                        JP    __READ_BLOCK                   
                         258   _WRITE_BLOCK         EQU   $                              
                         259                        JP    __WRITE_BLOCK                  
                         260   _MODE_CHECK          EQU   $                              
                         261                        JP    __MODE_CHECK                   
                         262   _SCAN_FOR_FILE       EQU   $                              
                         263                        JP    __SCAN_FOR_FILE                
                         264   _FILE_QUERY          EQU   $                              
                         265                        JP    __FILE_QUERY                   
                         266   _POSIT_FILE          EQU   $                              
                         267                        JP    __POSIT_FILE                   
                         268   _EOS_1               EQU   $                              
                         269                        JP    __EOS_1                        
                         270   _EOS_2               EQU   $                              
                         271                        JP    __EOS_2                        
                         272   _EOS_3               EQU   $                              
                         273                        JP    __EOS_3                        
                         274   _CV_A                EQU   $                              
                         275                        JP    _CV_A                          
                         276   
                         277   _PORT_COLLECTION     EQU   $                              
                         278                        JP    __PORT_COLLECTION              
                         279   _SWITCH_MEM          EQU   $                              
                         280                        JP    __SWITCH_MEM                   
                         281   _PUT_ASCII           EQU   $                              
                         282                        JP    __PUT_ASCII                    
                         283   
                         284   ;
                         285   ; micro  OS7 entries
                         286   ;
                         287   
                         288   WRITE_VRAM           EQU                                  
                         289                        JP    __WRITE_VRAM                   
                         290   READ_VRAM            EQU                                  
                         291                        JP    __READ_VRAM                    
                         292   WRITE_REGISTER       EQU                                  
                         293                        JP    __WRITE_REGISTER               
                         294   READ_REGISTER        EQU                                  
                         295                        JP    __READ_REGISTER                
                         296   FILL_VRAM            EQU                                  
                         297                        JP    __FILL_VRAM                    
                         298   INIT_TABLE           EQU                                  
                         299                        JP    __INIT_TABLE                   
                         300   PUT_VRAM             EQU                                  
                         301                        JP    __PUT_VRAM                     
                         302   GET_VRAM             EQU                                  
                         303                        JP    __GET_VRAM                     
                         304   CALC_OFFSET          EQU                                  
                         305                        JP    __CALC_OFFSET                  
                         306   PX_TO_PTRN_POS       EQU                                  
                         307                        JP    __PX_TO_PTRN_POS               
                         308   LOAD_ASCII           FQU                                  
                         309                        JP    __LOAD_ASCII                   
                         310   WR_SPR_ATTRIBUTE     EQU                                  
                         311                        JP    __WR_SPR_ATTRIBUTE             
                         312   POLLER               EQU                                  
                         313                        JP    __POLLER                       
                         314   UPDATE_SPINNER       EQU                                  
                         315                        JP    __UPDATE_SPINNER               
                         316   DECLSN               EQU                                  
                         317                        JP    __DECLSN                       
                         318   DECMSN               EQU   $                              
                         319                        JP    __DECMSN                       
                         320   MSNTOLSN             EQU   $                              
                         321                        JP    __MSNTOLSN                     
                         322   ADD816               EQU   $                              
                         323                        JP    __ADD816                       
                         324   SOUND_INIT           EQU   $                              
                         325                        JP    __SOUND_INIT                   
                         326   TURN_OFF_SOUND       EQU   $                              
                         327                        JP    __TURN OFF_SOUND               ;not globalized    in os7?
                         328   PLAY_IT              EQU   $                              
                         329                        JP    __PLAY_IT                      
                         330   SOUNOS               EQU   $                              
                         331                        JP    __SOUNDS                       ;equals  calls  to  play songs   and  sound_man
                         332   EFFECT_OVER          EQU   $                              
                         333                        JP    __EFFECT_OVER                  
                         334   
                         335   
                         336   ;  NOTE:   See  INTERRUPT VECTORS
                         337   
                         338                        ORG   EOS_GLB_TBL                    
                         339                                                             ;GLB     VECTOR_O8H
                         340   ;VECTOR_OBH     EQU      $+0
                         341                                                             ;GLB     INT_VCTR_TBL
                         342   ;INT_VCTR_TBL   EQU      VECTOR_O8H
                         343   ;               ;GLB     VECTOR_10H
                         344   ;VECTOR_10H     EQU      $+3
                         345                                                             ;GLB     VECTOR_18H
                         346   ;VECTOR_18H     EQU      $+6
                         347                                                             ;GLB     VECTOR20H
                         348   ;VECTOR_20H     EQU      $+9
                         349                                                             ;GLB     VECTOR_28H
                         350   ;VECTOR_28H     EQU      $+12
                         351                                                             ;GLB     VECTOR_30H
                         352   ;VECTOR_30H      EQU     $+15
                         353                                                             ;GLB     VECTOR38H
                         354   ;VECTOR_36H     EQU      $+18
                         355                                                             ;GLB     VECTOR_66H
                         356   ;VECTOR_66H     EQU      $+21
                         357   
                         358   ;
                         359   ;     NOTE: See SWITCHTABLE
                         360   ;
                         361   ;               ;GLB     MEMCNF GOO
                         362   ;MEM_CNFGOO     EQU     $+24
                         363   ;;              ;GLB     SWITCHTABLE
                         364   ;SWITCH_TABLE   EQU     MEMCNFGOO
                         365   ;;              ;GLB     MEMCNFGOI
                         366   ;MEM_CNFGO1     EQU     $+25
                         367   ;;              ;GLB     MEMCNFGO2
                         368   ;MEM_CNFGO2     EQU     $+26
                         369   ;;              ;GLB     MEMCNFGO3
                         370   ;MEM_CNFGO3     EQU     $+27
                         371   ;;              ;GLB     MEMCNFGO4
                         372   ;MEM_CNFGO4     EQU     $+28
                         373   ;;              ;GLB     MEMCNFGOS
                         374   ;MEM_CNFGOS     EQU     $+29
                         375   ;;              ;GLB     MEM_CNFGO6
                         376   ;MEM_CNFGO6     EQU     $+30
                         377   ;;              ;GLB     MEM_CNFGO7
                         378   ;MEM_CNFGO7     EQU     $+31
                         379   ;;              ;GLB     MEMCNFGOS8
                         380   ;MEM_CNFGOS     EQU     $+32
                         381   ;;              ;GLB     MEMCNF GOS
                         382   ;MEM_CNFGOS     EQU     $+33
                         383   ;;              ;GLB     MEMCNFGOA
                         384   ;MEM_CNFGOA     EQU     $+34
                         385   ;;              ;GLB     MEMCNF GOB
                         386   ;MEM_CNFGOS     EQU     $+35
                         387   ;;              ;GLB     MEM_CNFGOC
                         388   ;MEM_CNFGOC     EQU     $+36
                         389   ;;              ;GLB     MEM_CNFGOD
                         390   ;MEM_CNFGOD     EQU     $+37
                         391   ;;              ;GLB     MEM_CNFGOE
                         392   ;MEM_CNFGOE     EQU     $+38
                         393   ;;              ;GLB     MEM_CNFGOF
                         394   ;MEM_CNFGOF    EQU     $+39
                         395   
                         396   ;
                         397   ;        NOTE:   See  PORT  TABLE
                         398   ;
                         399   ;;                     ;GLB         MEM_SWITCH_PORT
                         400   ;MEM_SWITCH_PORT  EQU        $+40
                         401   ;;                    ;GLB PORT_TABLE
                         402   ;PORT_TABLE          EQU        MEM_SWITCH_PORT
                         403   ;;                 ;GLB NET_RESET_PORT
                         404   ;NET_RESET_PORT       EQU        $+41
                         405   ;;                 ;GLB        VDP_CTRL_PORT
                         406   ;VOP_ CTRL_PORT       EQU         $+42
                         407   ;;                 ;GLB        VDP_DATA_PORT
                         408   ;VDP_DATA_PORT       EQU        $+43
                         409   ;;                   ;GLB         CONTROLLER_0_PORT
                         410   ;CONTROLLER_0_PORT    EQU       $+44
                         411   ;;                  ;GLB     CONTROLLER_1_PORT
                         412   ;CONTROLLER_1_PORT   EQU     $+45
                         413   ;;                  ;GLB     STROBE_SET_PORT
                         414   ;STROBE_SET_PORT   ;EQU        $+46
                         415   ;;                      ;GLB         STROBE_RESET_PORT
                         416   ;STROBE_RESET_PORT ;EQU     $+47
                         417   ;;                  ;GLB      SOUNDPORT
                         418   ;;SOUNDPORT            EQU         $+48
                         419   
                         420   
                         421   ;RAM DEFINITIONS  FOR EOS
                         422   
                         423   ;REV O          (v/D     8-24-83)
                         424   
                         425   
                         426   ; ************************************************
                         427   
                         428                        ORG   EOS_GLB_RAM                    
                         429   
                         430   ; ************************************************
                         431   
                         432                                                             ;GLB      CLEAR_RAMSTART
                         433   
                         434   CLEAR_RAM_START:                                          
                         435   
                         436   ;
                         437   ; EOS revision  number initialized  by  EOS START
                         438   ;
                         439                                                             ;GLB      REV_NUM
                         440   REV_NUM                                                   
                         441                        DEFS  1                              
                         442   
                         443   
                         444                        IF    ,NT,SUPERGAME                  
                         445   ;
                         446   ; 0S7 equivalent  global data structures
                         447   ;
                         448                                                             ;GLB     VDP_MODE WORD
                         449   VOP_MODEWORD         DEFS  2                              
                         450                                                             ;GLB     VOP_STATUS  BYTE
                         451   VOP_STATUSBYTE       DEFS  1                              
                         452                                                             ;GLB     VRAM_ADDR_ TABLE
                         453   VRAM_ADDR_TABLE                                           
                         454                                                             ;GLB     SPRITEATTRIBL
                         455   SPRITEATTRIBL        DEFS  2                              
                         456                                                             ;GLB     SPRITEGENTBL
                         457   SPRITEGENTBL         DEFS  2                              
                         458                                                             ;GLB     PATTRNNAME TBL
                         459   PATTRNNAMETBL        DEFS  2                              
                         460                                                             ;GLB     PATTRNGENTBL
                         461   PATTRNGENTBL         DEFS  2                              
                         462                                                             ;GLB     COLORTABLE
                         463   COLORTABLE           DEFS  2                              
                         464                        ELSE                                 
                         465                        DEFS  2*6+1                          
                         466                        ENDIF                                
                         467                                                             ;GLB     CUR_BANK
                         468   CURBANK              DEFS  1                              
                         469   
                         470   
                         471   ;
                         472   ; EOS global  data structures
                         473   ;
                         474                                                             ;GLB      DEFAULTBT  DEV
                         475                                                             ;GLB      CURRENTDEV
                         476   
                         477   OEFAULTBT_DEV:                                            
                         478   CURRENTDEV:                                               
                         479                        DEFS  1                              
                         480   
                         481                                                             ;GLB      CURRENTPCB
                         482   
                         483   CURRENTPCB:                                               
                         484                        DEFS  2                              ; HOLDS THE START ADDRESS OF THE PCB
                         485                        IF    ,NT,SUPERGAME                  
                         486                                                             ;GLB      DEVICEI0
                         487                        ENDIF                                
                         488   DEVICEID:                                                 
                         489                        DEFS  1                              ; SAVE DEVICE ID
                         490   
                         491   ;GLB      FILE NAME_ADDR
                         492   FILENAME             ADDR                                 
                         493                        DEFS  2                              
                         494   
                         495                                                             ;GLB      KEYBOARDBUFFER
                         496   
                         497   KEYBOARDBUFFER:                                           
                         498                        DEFS  1                              ; HOLDS THE KEY THAT IS READ FROM THE
                         499                                                             ; KEYBOARD
                         500   
                         501                                                             ;GLB      PRINTBUFFER
                         502   
                         503   PRINTBUFFER:                                              
                         504                        DEFS  16                             ; HOLDS THE STRING TO BE PRINTED
                         505   
                         506                                                             ;GLB      SECTORS_TO_INIT,SECTOR_NO
                         507   
                         508   SECTORS_TO_INIT:                                          
                         509                        DEFS  1                              
                         510   
                         511   SECTOR_NO:                                                
                         512                        DEFS  4                              
                         513   
                         514                                                             ;GLB      DCB_IMAGE
                         515   
                         516   DCB_IMAGE:                                                
                         517                        DEFS  21                             
                         518   
                         519                                                             ;GLB      QUERY_BUFFER
                         520   QUERY_BUFFER                                              
                         521                        DEFS  DIR_ENT_LENGTH                 
                         522   
                         523                                                             ;GLB      FCB_BUFFER
                         524   FCB_BUFFER                                                
                         525                        DEFS  DIR_ENT_LENGTH                 
                         526   
                         527                                                             ;GLB      FILE COUNT, MOD_FILE COUNT
                         528   FILE_COUNT                                                
                         529                        DEFS  1                              
                         530   
                         531   MOD_FILE             COUNT                                
                         532                        DEFS  1                              
                         533   
                         534                                                             ;GLB       RETRY COUNT,   FILE NUMBR
                         535   RETRY_COUNT                                               
                         536                        DEFS  1                              
                         537   
                         538   FILE_NUMBR                                                
                         539                        DEFS  1                              
                         540   
                         541                                                             ;GLB       FILENAME_CMPS
                         542   FILENAME_CMPS                                             
                         543                        DEFS  1                              
                         544   
                         545                                                             ;GLB      DIR_BLOCK_NO,FOUND_AVAIL_ENT
                         546   DIR_BLOCK_NO                                              
                         547                        DEFS  2                              
                         548   
                         549   FOUND_AVAIL_ENT                                           
                         550                        DEFS  1                              
                         551   
                         552                                                             ;GLB       VOL_BLK_SZ,BLK_STRT     PTR
                         553   BLK_STRT_PTR:                                             
                         554   VOL_BLK_SZ:                                               
                         555                        DEFS  4                              
                         556   
                         557   ; FILE  MANAGER   RAM  STORAGE
                         558   
                         559                                                             ;GLB       EOS_YEAR,EOS   MONTH,EOSDAY
                         560   EOS_YEAR             DEFS  1                              ;FMGR’S DATE STORAGE
                         561   EOS_MONTH            DEFS  1                              
                         562   EOS_DAY              DEFS  1                              
                         563   
                         564                                                             ;GLB       FMGR_DIR_ENT
                         565   FMGR_DIR_ENT                                              ;PLACEFOR FMGR TO PUT A DIR. ENTRY
                         566   
                         567                                                             ;GLB        FCB_HEAD_ADOR,FCB_DATA_ ADDR
                         568   FCB_HEAD_ADDR        DEFS  2                              ;POINTER TO START OF FCB HEADS
                         569   FCB_DATA_ADDR        DEFS  2                              ;POINTER TO START OF FCB BUFFERS
                         570   
                         571                                                             ;GLB         FNUM, BYTES REQ,BYTES TO GO,USER BUF
                         572                                                             ;GLB         BUF_START,BUF_ENO.BLOCKS  REQ
                         573                                                             ;GLB        USER_NAME  ,STARTBLOCK
                         574   FNUM                 DEFS  1                              ;FILE NUMBER GIVEN TO READ/WRITE ROUTINES
                         575   BYTES_REQ            DEFS  2                              ;NUMBER OF BYTES REQUESTED BY CALLER
                         576   BYTES_TO_GO          DEFS  2                              ;NUMBER OF BYTES STILL TO GIVE TO CALLER
                         577   USER_BUF             DEFS  2                              ;ADDRESS OF CALLER’S BUFFER
                         578   BUF_START            DEFS  2                              ;ADDRESS OF MY OWN BUFFER
                         579   BUF_END              DEFS  2                              ;ADDRESS OF END + 1 OF MY BUFFER
                         580   BLOCKS_REQ           DEFS  4                              ;NUMBER OF BLOCKS REQUESTED (MAKEFILE)
                         581   USER_NAME            DEFS  2                              ;POINTER TO USER’S NAME STRING
                         582   START_BLOCK          DEFS  4                              ;START BLOCK # OF A FILE
                         583   
                         584                                                             ;GLB_      NEW_HOLE  START,NEW_HOLE    SIZE
                         585   
                         586   NEW_HOLE             START                                
                         587                        DEFS  4                              
                         588   
                         589   NEW_HOLE_SIZE                                             ;
                         590                        DEFS  2                              
                         591   
                         592   STACK_START:                                              
                         593                        DEFS  60                             
                         594   
                         595                                                             ;GLB      EOSSTACK
                         596   EOS_STACK:                                                
                         597   
                         598   ;            ;GLB      SAVEDCOUNT
                         599                                                             ; controller data area
                         600                                                             ;GLB      SPIN_SWOCT                 ; THESE TWO BYTES MUST  GE IN THIS ORDER!!!
                         601                                                             ;GLB      SPIN_SW1CT
                         602                                                             ;GLB      PERSONAL ODEBOUNCETABLE
                         603                                                             ;GLB      TEMP STACK                 ; Used Dy putascit  when  bank switching
                         604                                                             ; sound data areas
                         605                                                             ;GLB      PTRTO LST  OF SND_ADORS
                         606                                                             ;GLB      PTRTO S GN_O
                         607                                                             ;GLB      PTR_TO_S_ON1
                         608                                                             ;GLB      PTR_TO_SON  2
                         609                                                             ;GLB      PTRTO S ON  3
                         610                                                             ;GLB      SAVECTRL
                         611   
                         612   
                         613   ;SAVEDCOUNT      DEFS      2
                         614   ;
                         615   ; controller  data  area
                         616   ;
                         617   SPIN_SWO_CT          DEFS  1                              ; THESE  TWO BYTES MUST BE IN THIS ORDER!!!
                         618   SPIN_SW1_CT          DEFS  1                              
                         619   PERSONAL_DEBOUNCE_TABLE DEFS  8                              
                         620                        DEFS  12                             ;USED BY TEMP_STACK
                         621   TEMP_STACK           EQU   $                              ;Used by put_ascii when bank switching
                         622   
                         623   ;
                         624   ; sound data  areas
                         625   ;
                         626   PTR_TO_LST_OF_SND_ADDRS DEFS  2                              
                         627   PTR_TO_S_ON_O        DEFS  2                              
                         628   PTR_TO_S_ON_1        DEFS  2                              
                         629   PTR_TO_S_ON_2        DEFS  2                              
                         630   PTR_TO_S_ON_3        DEFS  2                              
                         631   SAVE_CTRL            DEFS  1                              
                         632   
                         633   
                         634   ;
                         635   ; data  area  for   CONS OUT
                         636   ;
                         637                                                             ;GLB       OLDCHAR_
                         638                                                             ;GLB       XMIN
                         639                                                             ;GLB       XMAX
                         640                                                             ;GLB       YMIN
                         641                                                             ;GLB       Y_ MAX
                         642                                                             ;GLB       LINEBUFFER_
                         643                                                             ;GLB       NUM_LINES
                         644                                                             ;GLB       NUM_COLUMNS
                         645                                                             ;GLB       UPPER_LEFT
                         646                                                             ;GLB       PTRN_NAME_TBL
                         647                                                             ;GLB       CURSOR
                         648   
                         649   OLDCHAR_             DEFS  1                              ;Storage   of   char  under   cursor
                         650   X_MIN                DEFS  1                              ;Absolute    X  coord  of   window
                         651   X_MAX                DEFS  1                              
                         652   YMIN                 DEFS  1                              
                         653   YMAX                 DEFS  1                              
                         654   LINEBUFFER_          DEFS  33                             
                         655   NUMLINES             DEFS  1                              
                         656   NUM_COLUMNS          DEFS  1                              
                         657   UPPER_LEFT           DEFS  2                              
                         658   PTRN_NAME_TBL        DEFS  2                              
                         659   CURSOR               DEFS  2                              
                         660   
                         661                                                             ;GLB        CLEAR_RAM_SIZE
                         662   
                         663   CLEAR_RAM_SIZE       EQU   [$-CLEAR_RAM_START]            
                         664   
                         665   ;
                         666   ; this  is  the PCB/DCB  area
                         667   ;
                         668   ;***********************************************************************
                         669   
                         670                        ORG   EOS_PCB_DCB                    
                         671   
                         672   ;***********************************************************************
                         673   
                         674                                                             ;GLB      PCB
                         675   
                         676   PCB:                                                      
                         677                        DEFS  P_SIZE                         ; PCB
                         678   
                         679   DCBS:                                                     
                         680                        DEFS  15*D_SIZE                      ; 1 OCB PER NETWORK  ADORESS
                         681   
                         682   RESERVED_BYTE:                                            
                         683                        DEFS  1                              ; SAVED IN CASE WE OO  FAST  DMA HERE
                         684   ;
                         685   ;***********************************************************************
                         686   ;***********************************************************************
                         687   ;***********************************************************************
                         688   
                         689   NAME ^Rev OO - RPD^
                         690   
                         691   
                         692   ;***********************************************************************
                         693   
                         694                        ORG   EOS_GLB_TBL                    
                         695   
                         696   ;***********************************************************************
                         697   ;
                         698   ; NOTE: these are defined globa! in £0S_COMN
                         699   ;
                         700   ;                     ;GLB     VECTOR_O8H
                         701   ;                     ;GLB     VECTOR 10H
                         702   ;                     ;GLB     VECTOR_18H
                         703   ;                     ;GLB     VECTOR_20H
                         704   ;                     ;GLB     VECTOR_28H
                         705   ;                     ;GLB     VECTOR_30H
                         706   ;                     ;GLB     VECTOR_38H
                         707   ;                     ;GLB     VECTOR_66H
                         708   ;
                         709   VECTOR_O8H           RET                                  ;rst 8
                         710                        NOP                                  
                         711                        NOP                                  
                         712   VECTOR_10H           RET                                  ;rst 10
                         713                        NOP                                  
                         714                        NOP                                  
                         715   VECTOR_18H           RET                                  ;rst 18
                         716                        NOP                                  
                         717                        NOP                                  
                         718   VECTOR_20H           RET                                  ;rst 20
                         719                        NOP                                  
                         720                        NOP                                  
                         721   VECTOR_28H           RET                                  ;rst 28
                         722                        NOP                                  
                         723                        NOP                                  
                         724   VECTOR_30H           RET                                  ;rst30
                         725                        NOP                                  
                         726                        NOP                                  
                         727   VECTOR_38H           RET                                  ;rst38
                         728                        NOP                                  
                         729                        NOP                                  
                         730   VECTOR_66H           RETN                                 ;nmi vector
                         731                        NOP                                  
                         732   
                         733   
                         734   
                         735   
                         736   ; NOTE: these are defined global in EQSCOMN
                         737   
                         738   ;             ;GLB     SWITCH_TABLE
                         739   ;             ;GLB     MEM_CNFGOO
                         740   ;             ;GLB     MEM_CNFGO1
                         741   ;             ;GLB     MEM_CNFGO2
                         742   ;             ;GLB     MEM_CNFGO3
                         743   ;             ;GLB     MEM_CNFGO4
                         744   ;             ;GLB     MEM_CNFGO5
                         745   ;             ;GLB     MEM_CNFGO6
                         746   ;             ;GLB     MEM_CNFGO7
                         747   ;             ;GLB     MEM_CNFGO8
                         748   ;             ;GLB     MEM_CNFGO9
                         749   ;             ;GLB     MEM_CNFGOA
                         750   ;             ;GLB     MEM_CNFGOB
                         751   ;             ;GLB     MEM_CNFGOC
                         752   ;             ;GLB     MEM_CNFGOD
                         753   ;             ;GLB     MEM_CNFGOE
                         754   ;             ;GLB     MEM_CNFGOF
                         755   
                         756   LO_BOOT_ROM_N_ALPHA_MASK EQU   0000B                          
                         757   LO_INTRINSIC_RAM_TO_7FFFH_MASK EQU   0001B                          
                         758   LO_EXPANSION_0_TO_7FFFH_MASK EQU   0010B                          
                         759   LO_OS7_N_INTRINSIC_2000H_7FFFH_MASK EQU   0011B                          
                         760   
                         761   HI_INTRINSIC_8000H_TO_0FFFFH_MASK EQU                                  
                         762   HI_AUXILLIARY_SLOT_8000H_0FFFFH EQU   0100B                          
                         763   HI_EXPANSION_8000H_TO_0FFFFH_MASK EQU   1000B                          
                         764   HI_COLECOVISION_CARTRIOGE_SLOT EQU   1100B                          
                         765   
                         766   
                         767   
                         768   SWITCH_TABLE:                                             
                         769   
                         770   MEM_CNFGOO                                                
                         771                        DEFB  HI_INTRINSIC_8000H_TO_0FFFFH_MASK,OR,LO_BOOTROM_N_ALPHA_MASK 
                         772   
                         773   MEM_CNFGO1                                                
                         774                        DEFB  HI_INTRINSIC_8000H_TO_0FFFFH_MASK,OR,LO_INTRINSIC_RAM_0_TO_7FFFH_MASK 
                         775   
                         776   MEM_CNFGO2                                                
                         777                        DEFB  HI_INTRINSIC_8000H_TO_0FFFFH_MASK,OR,LO_EXPANSION_0_TO_7FFFH_MASK 
                         778   
                         779   MEM_CNFGO3                                                
                         780                        DEFB  HI_INTRINSIC_8000H_TO_0FFFFH_MASK,OR,LO_OS7_N_INTRINSIC_2000H_7FFFH_MASK 
                         781   
                         782   MEM_CNFGO4                                                
                         783                        DEFB  HI_AUXILLIARY_SLOT_8000H_0FFFFH,OR,LO_BOOT_ROM_N_ALPHA_MASK 
                         784   
                         785   MEM_CNFGO5                                                
                         786                        DEFB  HI_AUXILLIARY_SLOT_8000H_0FFFFH,OR,LO_INTRINSIC_RAM_0_TO_7FFF_MASK 
                         787   
                         788   MEM_CNFGO6                                                
                         789                        DEFB  HI_AUXILLIARY_SLOT_8000H_0FFFFH,OR,LO_EXPANSION_0_TO_7FFF_MASK 
                         790   
                         791   MEM_CNFGO7                                                
                         792                        DEFB  HI_AUXILLIARY_SLOT_8000H_0FFFFH,OR,LO_OS7_N_INTRINSIC_2000H_7FFFH_MASK 
                         793   
                         794   MEM_CNFGO8                                                
                         795                        DEFB  HI_EXPANSION_8000H_TO_0FFFFH_MASK,OR,LO_BOOT_ROM_N_ALPHA_MASK 
                         796   
                         797   MEM_CNFGO9                                                
                         798                        DEFB  HI_EXPANSION_8000H_TO_0FFFFH_MASK,OR,LO_INTRINSIC_RAM_0_TO_7FFFH_MASK 
                         799   
                         800   MEM_CNFGOA                                                
                         801                        DEFB  HI_EXPANSION_8000H_TO_0FFFFH_MASK,OR,LO_EXPANSION_0_TO_7FFFH_MASK 
                         802   
                         803   MEM_CNFGOB                                                
                         804                        DEFB  HI_EXPANSION_8000H_TO_0FFFFH_MASK,OR,LO_OS7_N_INTRINSIC_2000H_7FFFH_MASK 
                         805   
                         806   MEM_CNFGOC                                                
                         807                        DEFB  HI_COLECOVISION_CARTRIDE_SLOT,OR,LO_BOOT_ROM_N_ALPHA_MASK 
                         808   
                         809   MEM_CNFGOD                                                
                         810                        DEFB  HI_COLECOVISION_CARTRIDE_SLOT,OR,LO_INTRINSIC_RAM_0_TO_7FFFH_MASK 
                         811   
                         812   MEM_CNFGOE                                                
                         813                        DEFB  HI_COLECOVISION_CARTRIDE_SLOT,OR,LO_EXPANSION_0_TO_7FFFH_MASK 
                         814   
                         815   MEM_CNFGOF                                                
                         816                        DEFB  HI_COLECOVISION_CARTRIDE_SLOT,OR,LO_OS7_INTRINSIC_2000H_7FFFH_MASK 
                         817   
                         818   
                         819   
                         820   ;
                         821   ;  NOTE:       these      are    defined       global       in    E0S_COMN
                         822   ;
                         823   ;                                       ;GLB            PORT_TABLE           ;port value memory locations
                         824   ;                                       ;GLB            MEM_SWITCH_PORT
                         825   ;                                       ;GLB            NET_RESET_PORT
                         826   ;                                       ;GLB            VOP_CTRL_PORT
                         827   ;                                       ;GLB            VOP_DATA_PORT
                         828   ;                                       ;GLB            CONTROLLER_O_PORT
                         829   ;                                       ;GLB            CONTROLLER_1_PORT
                         830   ;                                       ;GLB            STROBE_SET_PORT
                         831   ;                                       ;GLB            STROBE_RESET_PORT
                         832   ;                                       ;GLB            SOUNODPORT
                         833   ;
                         834   ; ******************************************************
                         835   ; *** VDP ports must remain next to each other       ***
                         836   ; ***   and in CTRL -> DATA order                    ***
                         837   ; ******************************************************
                         838   
                         839   PORT_TABLE:                                               
                         840   
                         841   MEM_SWITCH_PORT                                           
                         842                        DEFB  07FH                           ;MEM_SWITCH_PORT         defined here
                         843   
                         844   NET_RESET_PORT                                            
                         845                        DEFB  03FH                           ;Adam_net reset port     defined here
                         846   
                         847   VOP_CTRL_PORT                                             
                         848                        DEFB  0BFH                           ;VDP ctrl port           01D43H
                         849   
                         850   VDP_DATA_PORT                                             
                         851                        DEFB  0BEH                           ;VOP data port           01D47H
                         852   
                         853   CONTROLLER_O_PO                                           
                         854                        DEFB  0FCH                           ;Controller O            0114BH
                         855   
                         856   CONTROLLER_1_PO                                           
                         857                        DEFB  0FFH                           ;Controller 1            01151H
                         858   
                         859   STROBE_SET_PORT                                           
                         860                        DEFB  080H                           ;Controller strobe set   01157H
                         861   
                         862   STROBE_RESET_PO                                           
                         863                        DEFB  0C0H                           ;Controller strobe reset 01168H
                         864   
                         865   SOUNODPORT                                                
                         866                        DEFB  0FFH                           ;Sound port              0018EH
                         867   ;
                         868   ; ******************************************************
                         869   ; ******************************************************
                         870   ; ******************************************************
                         871   
                         872   
                         873   
                         874   ;
                         875   ; globals routines defined
                         876   ;
                         877                                                             ;GLB      __WRITEVRAM                 ;VDP support routines
                         878                                                             ;GLB      __READ_VRAM
                         879                                                             ;GLB      __WRITEREGISTER
                         880                                                             ;GLB      __READ_REGISTER
                         881                                                             ;GLB      __FILL_VRAM
                         882                                                             ;GLB      __INIT_TABLE
                         883                                                             ;GLB      __PUT_VRAM
                         884                                                             ;GLB      __GET_VRAM
                         885                                                             ;GLB      __CALC_OFFSET
                         886                                                             ;GLB      __PX_TO_PTRN_POS
                         887                                                             ;GLB      __LOAD_ASCTII
                         888                                                             ;GLB      __PuT_ASCII
                         889                                                             ;GLB      __WR_SPR_ATTRIBUTE
                         890   
                         891                                                             ;GLB      __DECODER
                         892                                                             ;GLB      __POLLER                    ;controller support routines
                         893                                                             ;GLB      __UPDATE_SPINNER
                         894   
                         895                                                             ;GLB      __DECLSN                    ;sound chip support routines
                         896                                                             ;GLB      __DECMSN
                         897                                                             ;GLB      __MSNTOLSN
                         898                                                             ;GLB      __ADD816
                         899                                                             ;GLB      ___SOUND_INIT
                         900                                                             ;GLB      __TURN_OFF_SOUND
                         901                                                             ;GLB      __PLAY_IT
                         902                                                             ;GLB      ___SOUNODS
                         903                                                             ;GLB      __EFFECT_OVER
                         904   
                         905                                                             ;GLB      __SWITCH_MEM                ;memory bank switch support routine
                         906                                                             ;GLB      __PORTCOLLECTION            ;STORE THE PORT ADDRESSES FROM OS 7
                         907   
                         908   ;
                         909   ; external data areas used
                         910   ;
                         911                                                             ;EXT       VDP_MODEWORD
                         912                                                             ;EXT       VDP_STATUSBYTE
                         913                                                             ;EXT       VRAM_ADDR [FABLE
                         914                                                             ;EXT       SPRITEATTRIBLS
                         915   ;eee          ;EXT       SPRITEGENTBL
                         916   ;eee          ;EXT       PATTRNNAMETBL
                         917                                                             ;EXT       PATTRNGENTBL
                         918   ;eee          ;EXT       COLORTABLE
                         919                                                             ;EXT       CUR_BANK
                         920   
                         921                                                             ;controller data area
                         922                                                             ;EXT       SPIN_SWO_CT                 ;THESE TWO BYTES MUST BE IN THIS ORDER!!!
                         923   ;ee@e         ;EXT       SPIN_SW1_CT
                         924                                                             ;EXT       PERSONAL_DEBOUNCE_TABLE
                         925                                                             ;EXT       TEMP_STACK                    ;Used by put_ascii when bank switching
                         926                                                             ;sound data areas
                         927                                                             ;EXT       PTR_TO_LST OF_SND_ADDRS
                         928                                                             ;EXT       PTR_TO_S_ON_0
                         929                                                             ;EXT       PTR_TO_S_ON_1
                         930                                                             ;EXT       PTR_TO_S_ON_2
                         931                                                             ;EXT       PTR_TO_S_ON_3
                         932                                                             ;EXT       SAVE_CTRL
                         933   ;
                         934   ;    Port address and  bank  select  externals    follow
                         935   ;
                         936                                                             ;EXT       PORTTABLE
                         937                                                             ;EXT       MEM_SWITCH_ PORT
                         938   ;eee          ;EXT       NET_RESET_PORT
                         939                                                             ;EXT       VDP_CTRL_PORT
                         940   ;eee          ;EXT       VDP_DATA_PORT
                         941                                                             ;EXT       CONTROLLER_O_PORT
                         942   ;eee          ;EXT       CONTROLLER_1_PORT
                         943                                                             ;EXT       STROBE_SET_PORT
                         944   ;eee          ;EXT       STROBE_RESET_PORT
                         945                                                             ;EXT       SOUNDPORT
                         946   
                         947   ;eee          ;EXT       SWITCH_TABLE
                         948                                                             ;EXT       MEM_CNFGOO
                         949   ;ee@          ;EXT       MEM_CNFGO1
                         950   ;eee          ;EXT       MEM_CNFGO2
                         951                                                             ;EXT       MEM_CNFGO3
                         952   ;eee          ;EXT       MEM_CNFGO4
                         953   ;eee          ;EXT       MEM_CNFGO5
                         954   ;eee          ;EXT       MEM_CNFGO6
                         955   ;eee          ;EXT       MEM_CNFGO7
                         956   ;eee          ;EXT       MEM_CNFGO8
                         957   ;eee          ;EXT       MEM_CNFGO9
                         958   ;eee          ;EXT       MEM_CNFGOA
                         959   ;ee¢@         ;EXT       MEM_CNFGOB
                         960   ;ee@          ;EXT       MEM_CNFGOC
                         961   ;ee@          ;EXT       MEM_CNFGOD
                         962   ;ece@         ;EXT       MEM_CNFGOE
                         963   ;ee¢          ;EXT       MEM_CNFGOF
                         964   
                         965   ;
                         966   ; externals used
                         967   ;
                         968                                                             ;EXT      WRITE_REGISTER
                         969   ;eee          ;EXT      INIT_TABLE
                         970                                                             ;EXT      SWITCH_MEM
                         971   ;eee          ;EXT      PUT_VRAM
                         972                                                             ;EXT      WRITE_VRAM
                         973                                                             ;EXT      READ_VRAM
                         974   ;
                         975   ; local equates
                         976   ;
                         977   LOC_IN_ALPHA         EQU   0102H                          ;potnter  to  ascii  gens in rev  28+  alpha
                         978   
                         979   
                         980   
                         981   ; Offsets  into a volume   descriptor  (the first entry in the directory).
                         982   VOL_NAME             EQU   0                              ;LOGICALVOLUME NAME
                         983   VOL_DIRSIZE          EQU   12                             ;*ee7 BITS ONLY *** # BLOCKS IN DIRECTORY
                         984   VOL_ATTR             EQU   12                             ;**eTOP BIT ONLY ***SET FOR DELETE  PROTECTION
                         985   VOL_DIR_CHECK        EQU   13                             ;CONTAINS 4 UNIQUE BYTES FOR DIRECTORY   EXISTENCE   VERIFICATION
                         986   VOL_SIZE             EQU   17                             ;VOLUMESIZE (IN BLOCKS) (4 BYTES)
                         987   VOL_YEAR             EQU   23                             ;CREATIODATE -- YEAR
                         988   VOL_MONTH            EQU   24                             ;                MONTH
                         989   VOL_DAY              EQU   25                             ;                & DAY
                         990   VOL_DES_LENGTH       EQU   26                             
                         991   
                         992   ; Offsets  into a directory   entry.
                         993   DIR_NAME             EQU   0                              ;FILE NAME
                         994   DIR_ATTR             EQU   12                             ;FILE ATTRIBUTE BYTE
                         995   DIR_START_BLOCK      EQU   13                             ;STARTING BLOCK4
                         996   DIR_MAX_LENGTH       EQU   17                             ;TOTAL #4BLOCKS ALLOCATED
                         997   DIR_USED_LENGTH      EQU   19                             ;#OF BLOCKS USED (FULL + 1 PARTIAL)
                         998   DIR_LAST_COUNT       EQU   21                             ;NUMBER OF BYTES IN LAST PARTIAL BLOCK
                         999   DIR_YEAR             EQU   23                             ;CREATION DATE -- YEAR
                         1000  DIR_MONTH            EQU   24                             ;                MONTH
                         1001  DIR_DAY              EQU   25                             ;                & DAY
                         1002  DIR_ENT_LENGTH       DEFL  26                             
                         1003  
                         1004  ENT_PER_BLOCK        EQU   1024/26                        ;NUMBEROF ENTRIES PER DIR BLOCK
                         1005  
                         1006  ; Offsets  into an FCB  header.
                         1007  
                         1008  ; Copy of  DIR entry
                         1009  
                         1010  FCB_NAME             EQU   0                              ;FILE NAME
                         1011  FCB_ATTR             EQU   12                             ;FILE ATTRIBUTE BYTE
                         1012  FCB_START_BLOCK      EQU   13                             ;STARTING BLOCK ¥#
                         1013  FCB_FIRST_BLOCK      EQU   FCB_START_BLOCK                
                         1014  FCB_MAX_LENGTH       EQU   17                             ;TOTAL # BLOCKS ALLOCATED
                         1015  FCB_USED_LENGTH      EQU   19                             ;# OF BLOCKS USED (FULL + 1 PARTIAL)
                         1016  FCB_LAST_COUNT       EQU   21                             ;NUMBER OF BYTES IN LAST PARTIAL BLOCK
                         1017  
                         1018  FCB_STORED_BYTES     EQU   FCB_LAST_COUNT+1               ; NUMBER OF BYTES STORED  ON DEVICE
                         1019                                                            ; ... THE UPPER HALF OF THIS  FCB  EQU  LIST
                         1020  
                         1021  FCB_DEVICE           EQU   26-3                           ;NUMBER OF DEVICE CONTAINING  FILE
                         1022  FCB_MODE             EQU   27-3                           ;FILE MODE (UNUSED, READ,  WRITE,APPEND)
                         1023  FCB_BLOCK            EQU   28-3                           ;>BLOCKNUMBER CURRENTLY IN  BUFFER
                         1024  FCB_LAST_BLOCK       EQU   32-3                           ;LAST BLOCK NUMBER IN FILE
                         1025  FCB_POINTER          EQU   36-3                           ;-POINTERINTO BLOCK BUFFER
                         1026  FCB_LENGTH           EQU   38-3                           
                         1027  
                         1028  ; Possible  FCB modes.
                         1029  ;*
                         1030  ;* PROTECTED  MODE EQUATES
                         1031  ;*
                         1032  MODE_UNUSED          EQU   0                              ;MANY PEOPLE ASSUME THIS IS ZERO!
                         1033  MODE_READ            EQU   MODE_UNUSED+1                  
                         1034  MODE_WRITE           EQU   MODE_READ+1                    
                         1035  MODE_UPDATE          EQU   MODE_WRITE+1                   
                         1036  MODE_EXEC            EQU   MODE_UPDATE+1                  
                         1037  MODE_MAX             EQU   MODE_EXEC+0                    
                         1038  ;*
                         1039  MODE_REMAINDER_BIT   EQU   5                              ; INDICATES TO ALLOCATE REST  OF  TAPE
                         1040  MODE_DIRTY_BIT       EQU   6                              ; TEST BIT 6
                         1041  MODE_DIRTY           EQU   010000008                      ;INOICATES MODIFIED BUFFER
                         1042  MODE_LAST_BLOCK_BIT  EQU   7                              ; TEST BIT 7
                         1043  MODE_LAST            EQU   100000008                      ;INDICATES LAST BLOCK OF FILE
                         1044  MODE_MODE            EQU   000001118                      ;BITS TO STORE MODES
                         1045  
                         1046  ; File attribute bits.
                         1047  ATTR_PERMANENT       EQU   10000000B                      
                         1048  ATTR_WRITE_PROT      EQU   01000000B                      
                         1049  ATTR_READ_PROT       EQU   00100000B                      
                         1050  ATTR_USER            EQU   00010000B                      
                         1051  ATTR_SYSTEM          EQU   00001000B                      
                         1052  ATTR_DELETED         EQU   00000100B                      
                         1053  ATTR_DEL_BIT         EQU   2                              
                         1054  ATTR_EXECUTE         EQU   00000010B                      
                         1055  ATTR_HOLE_BIT        EQU   0                              
                         1056  ATTR_HOLE            EQU   00000001B                      
                         1057  
                         1058  ; System-wide file name length.
                         1059  NAME_LENGTH          EQU   12                             
                         1060  
                         1061  ; Numbers of things we nave.
                         1062  NUM_FCBS             EQU   3                              ;1 FOR THE SYSTEM, 2 FOR THE USER
                         1063  
                         1064  
                         1065  DCB_NOT_FOUND        EQU   1                              ;  THERE WAS NO DCB FOR  THE  DEVICE  REQUESTED.
                         1066  DCB_BUSY             EQU   2                              ;  OCB IS BUSY
                         1067  DCB_IDLE_ERR         EQU   3                              ;  OCB IS IOLE
                         1068  
                         1069  NO_DATE_ERR          EQU   4                              
                         1070  NO_FILE_ERR          EQU   5                              
                         1071  FILE_EXISTS_ERR      EQU   6                              
                         1072  NO_FCB_ERR           EQU   7                              
                         1073  MATCH_ERR            EQU   8                              
                         1074  BAD_FNUM_ERR         EQU   9                              
                         1075  EOF_ERR              EQU   10                             
                         1076  TOOBIG_ERR           EQU   11                             
                         1077  FULL_DIR_ERR         EQU   12                             
                         1078  FULL_TAPE_ERR        EQU   13                             
                         1079  FILE_NM_ERR          EQU   14                             ;0LS(8/28/83)
                         1080  RENAME_ERR           EQU   15                             ;DLS(8/30/83)
                         1081  DELETE_ERR           EQU   16                             ;DLS(8/30/83)
                         1082  RANGE_ERR            EQU   17                             ;DLS(8/31/83)
                         1083  
                         1084  CANT_SYNC1           EQU   18                             
                         1085  CANT_SYNC2           EQU   19                             
                         1086  PRT_ERR              EQU   20                             
                         1087  
                         1088  RQ_TP_STAT_ERR       EQU   21                             
                         1089  DEVICE_DEPD_ERR      EQU   22                             
                         1090  PROG_NON_EXIST       EQU   23                             ; PROGRAM DOES NOT  CURRENTLY   EXIST
                         1091  NO_DIR_ERR           EQU   24                             ; NO DIRECTORY ON  TAPE
                         1092  
                         1093  
                         1094  ;THESE  OUR  EQUATES   THAT  ARE  USED  BY  THE  EOS  PROGRAMS   TO REFEFERNCE
                         1095  ;PCB AND  DCB INFORMATION
                         1096  
                         1097  
                         1098  ;PCB EQUATES
                         1099  
                         1100  P_COM_STAT           EQU   0                              ; THIS  IS  THE COMMAND/STATUS     BYTE
                         1101  
                         1102  P_REL_ADDR           EQU   1                              ; THIS  IS  THE RELOCATION    ADDRESS
                         1103  P_REL_AODR_LO        EQU   P_REL_ADDR+0                   
                         1104  P_REL_ADOR_HI        EQU   P_REL_ADDR+1                   
                         1105  
                         1106  P_NUM_DCBS           EQU   3                              ; THIS  IS  THE NUMBER   OF  DCBS  DEFINED
                         1107  
                         1108  
                         1109  P_SIZE               DEFL  4                              ; THE NUMBER   OF  BYTES  IN  THE  PCB
                         1110  
                         1111  
                         1112  
                         1113  ;DCB EQUATES
                         1114  
                         1115  D_COMSTAT            EQU   0                              ; THE  COMMANO   STATUS  BYTE
                         1116  
                         1117  D_BUF_ADR            EQU   1                              ; ADDRESS   OF  THE DATA   BUFFER
                         1118  D_BUF_ADR_LO         EQU   D_BUF_ADR+0                    
                         1119  D_BUF_ADR_HI         EQU   D_BUF_ADR+1                    
                         1120  
                         1121  D_BUF_LEN            EQU   3                              ; THE  LENGTH   OF THE  DATA  BUFFER
                         1122  D_BUF_LEN_LO         EQU   D_BUF_LEN+0                    
                         1123  D_BUF_LEN_HI         EQU   D_BUF_LEN+1                    
                         1124  
                         1125  D_SECT_NUM           EQU   5                              ; THE  BLOCK  DEVICE   SECTOR   NUMBER
                         1126  
                         1127  D_SEC_DEV_ID         EQU   9                              ; SECONDARY   DEVICE   ID
                         1128  
                         1129  D_RET_COUNT          EQU   14                             ; THE  NUMBER   OF TIMES  A  COMMAND   WILL
                         1130                                                            ; BE  RETRIED.
                         1131  D_RET_COUNT_LO       EQU   D_RET_COUNT+0                  
                         1132  D_RET_COUNT_HI       EQU   D_RET_COUNT+1                  
                         1133  
                         1134  D_DEV_ADDR           EQU   16                             ; THE  DEVICE   ADDRESS  (1D)
                         1135  
                         1136  D_MAX_MSG_LEN        EQU   17                             ; THE  MAX  LENGTH  OF  A DATA   STRING
                         1137                                                            ; FOR  THE  DEVICE
                         1138  D_MAX_MSG_LN_LO      EQU   D_MAX_MSG_LEN+0                
                         1139  D_MAX_MSG_LN_HI      EQU   D_MAX_MSG_LEN+1                
                         1140  
                         1141  D_DEV_TYPE           EQU   19                             ; THE  DEVICE   TYPE,  BLOCKED   OR CHARACTER
                         1142  
                         1143  D_STATUS_FLAGS       EQU   20                             ; DEVICE  DEPENDENT    STATUS  FLAGS
                         1144  
                         1145  D_SIZE               DEFL  21                             ; THE  NUMBER  OF  BYTES  IN  THE  DCB
                         1146  
                         1147  
                         1148  
                         1149  ;DEVICE  ID‘S  FOR  THE KEYBOARD,    PRINTER,   AND  TAPE  DRIVE
                         1150  
                         1151  KEYBOARD_ID          EQU   1                              ;KYBD   ID
                         1152  PRINTER_ID           EQU   2                              ;PRINTER  ID
                         1153  TAPE_ID              EQU   8                              ;TAPE DRIVE  ID
                         1154  
                         1155  ERROR_RETRY          EQU   2                              ;MAX RETRYS ON  ERRORS,   READ BLOCK  AND  WRITEBLOCK
                         1156  
                         1157  MAX_DEV_ADDR         EQU   15                             ;HIGEST POSSIBLE  DEVICE   ADDRESS
                         1158                                                            ; ON NETWORK
                         1159  
                         1160  
                         1161  ;PCB COMMAND   EQUATES
                         1162  
                         1163  
                         1164  PCB_IDLE             EQU   0                              ;THIS  ISAN  IDLE STATE
                         1165  
                         1166  PCB_SYNC1            EQU   1                              ;SYNC BYTE  1
                         1167  PCB_SYNC1_ACK        EQU   PCB_SYNC1+80H                  
                         1168  
                         1169  PCB_SYNC2            EQU   2                              ;SYNC BYTE 2
                         1170  PCB_SYNC2_ACK        EQU   PCB_SYNC2+80H                  
                         1171  
                         1172  PCB_SNA              EQU   3                              ; SET NEW PCB ADDRESS
                         1173  PCB_SNA_ACK          EQU   PCB_SNA+80H                    
                         1174  
                         1175  PCB_RESET            EQU   4                              ; RESET ALL NODES
                         1176  PCB_RESET_ACK        EQU   PCB_RESET+80H                  
                         1177  
                         1178  PCB_WAIT             EQU   5                              ;
                         1179  PCB_WAIT_ACK         EQU   PCB_WAIT+80H                   
                         1180  
                         1181  
                         1182  
                         1183  ;DCB COMMAND   EQUATES
                         1184  
                         1185  DCB_IDLE             EQU   00                             ;
                         1186  DCB_STATUS           EQU   01                             ; REQUEST STATUS
                         1187  DCB_RESET            EQU   02                             ; RESET NODE
                         1188  DCB_WR               EQU   03                             ; WRITE DATA TO DEVICE
                         1189  DCB_RD               EQU   04                             ; READ DATA FROM DEVICE
                         1190  
                         1191  
                         1192  
                         1193  INIT_PCB_ADDR        EQU   0FEC0H                         ; INITIAL ADDRESS  OF  THE PCB
                         1194  
                         1195  FCB_S                EQU   0D390H                         ; FCB HEADER AREA
                         1196  THREE1K_BLKS         EQU   0D400H                         ; 3K FCB DATA AREA
                         1197  
                         1198  
                         1199  ;GENERAL  USAGE  EQUATES    FOR USE WITH  DCB INFO
                         1200  
                         1201  CMND_COMPLETE_BIT    EQU   7                              ; THIS IS THE BIT  THAT  INDICATES   THE
                         1202                                                            ; COMMAND HAS BEEN  PROCESSED.
                         1203  CMND_FIN_STATUS      EQU   80H                            ; THIS IS THE STATUS  OF  A COMMAND
                         1204                                                            ; THAT COMPLETED WITH  NO  ERRORS
                         1205  KBD_NAK              EQU   BCH                            ; INDICATES NO KEY  READY
                         1206  
                         1207  PR_NAK               EQU   86H                            ; INDICATES THE PRINTER   IS BUSY
                         1208  
                         1209  ETX                  EQU   03H                            ; END OF DATA STRING INOICATOR
                         1210  
                         1211  TIMEOUT              EQU   9BH                            ; DEVICE TIMED OUT
                         1212  ;
                         1213  ;****************************************************************************************
                         1214  ;****************************************************************************************
                         1215  ;****************************************************************************************
                         1216  ;
                         1217  SKIP                                                      
                         1218  
                         1219  NAME ^Rev O7 - jki^
                         1220  
                         1221  ;DeA_uOS  OO MACRO               ;Header Rev. 5
                         1222  ;                .GOTO Ede_A_uOS_00
                         1223  
                         1224  ; Project:      ADAM, 83-101
                         1225  
                         1226  ;****************************************************************************************
                         1227  ;      sees                                                    eeee
                         1228  ;      eeee             A_uO000              RPD               seee
                         1229  ;     eee                                                     ess
                         1230  ;****************************************************************************************
                         1231  ;
                         1232  ;
                         1233  ;        Rev History
                         1234  ;        Rev.  Date         Name       Change
                         1235  ;         7    O8oct1545    jk         make  LOAD ASCII  load chars from  O to 7F
                         1236  ;         6    O8oct0003    rfj        Fixed 100H bug with Bob Greenberg's
                         1237  ;                                       algorithm
                         1238  ;         5    O7oct1708    rfj        __EFXOVER changed to _ EFFECT_OVER
                         1239  ;         4    OSoct10:40   rfj        Decoder now saves Acc before getting
                         1240  ;                                       interrupt data
                         1241  ;                                       Removed excess documentation on Put/Load   Ascii
                         1242  ;                                       Commented out all unreferenced symbols  with  ;eee
                         1243  ;                                       Renamed WRSPR_NM_TBL  to WR_SPR_ATTRIBUTE
                         1244  ;                                       globalized  UPDATE SPINNER
                         1245  ;                                       new address fcr the ASCII table  referenced
                         1246  ;         3    28septi3i7   rfj        Multy changes after personal review
                         1247  ;                                       but not approved
                         1248  ;         2    25sept900a   RPD        made ram externa!
                         1249  ;         1    24septi250p  RPO        addition of more routines & new port  accessing
                         1250  ;         O    24aug430p    RPO        Initial creation date (READ & WRITE  VRAM)
                         1251  ;
                         1252  ;A_u0SOO  stands for ADAM micro  Operating System version O. This file
                         1253  ;contains a scaled down mode! of  COLECOVISION OS 7. Primary routines from
                         1254  ;OS 7 are duplicated for ADAM application  programs use. The functional  areas
                         1255  ;that are supported by these routines  are the VDP, the controllers, the  sound
                         1256  ;chip, memory bank switch, port  collection.
                         1257  
                         1258  
                         1259  
                         1260  
                         1261  ;****************************************************************************************
                         1262  
                         1263                       ORG   EOS_CODE                       
                         1264  
                         1265  ;****************************************************************************************
                         1266  
                         1267  ;   Name:                WRITE_VRAM
                         1268  ;
                         1269  ;   Function:            Writes to VRAM the contents of the data in a buffer area.
                         1270  ;
                         1271  ;   Entry:               BC  -  number of bytes to be written
                         1272  ;                        DE  -  starting VRAM address to be written to
                         1273  ;                        HL  -  address of buffer containing the  data
                         1274  ;
                         1275  ;   Exit:                None.
                         1276  ;
                         1277  ;   Registers    used:   AF,  BC,   DE,   HL
                         1278  ;
                         1279  ;   Size:                ROM  -  28  bytes
                         1280  ;                        RAM  -  O  bytes
                         1281  ;
                         1282  ;   Comments:            This   version    of  WRITE   _VRAM   is  provided     for  EOS   operation.
                         1283  ;                        NOTE:   The   100H   bug   found   in  OS  7  has   been   corrected.
                         1284  ;
                         1285  ;   Comparision:         left  out   pascal    entry    point
                         1286  ;                        code  compacted
                         1287  ;                        100H  bug   fixed
                         1288  ;                        edited   for   documentation
                         1289  ;                        reference     port   table
                         1290  
                         1291  WRITE_VRAM:                                               
                         1292                       PUSH  BC                             ;BC   has   the  number    of  bytes    to  xfer
                         1293                       EX    DE,HL                          ;>HL<--vram     addr  ,0E<--source     address
                         1294                       CALL  SET_WRITE                         :PUMP    THE  VRAM   ADDR   TO  THE   VDP 
                         1295                       LD    L,C                            ;save    C  (the  data  _port_addr    )
                         1296                       POP   BC                             ;restore     the  xfer   count
                         1297                       EX    DE,HL                          ;HiL<--source     address,port       in€
                         1298                       LD    A,C                            ;Save    low  order   of  count     in A
                         1299                       LD    C,,€                           ;  And  get   the   port   into   C
                         1300                       LD    0,8                            ;Get   HI  order    count   in  DO
                         1301                                                            ;  to  free   up  B  for   low  order    count
                         1302                       INC   D                              ;Increment      Hi  count   to  cover
                         1303                                                            ;  for  O   in  DEC  D  after    low  loop
                         1304                       LD    B,A                            ;Put   low   order   in  86 for   OUTI
                         1305                       OR    A                              ;Check    tf  low   order   is  zero   the    first   time
                         1306                       JR    Z,OUT_DEC_HI_BYTE              ;If   so  then   decrement     Hi  count   before     low  loop
                         1307  OUTPUT_LOOP:                                              
                         1308                       OUTI                                 ;DATA  PORT     = buffer   data      write    the   data  to  the   VOP
                         1309                                                            ;>for   OUTI:    [C]  <--   [HL],   B  =  B  -   1 and  HL  =  HL  +  1
                         1310                       NOP                                  ;Gelay    for   stow  VOP
                         1311                       NOP                                  
                         1312                       JR    NZ,OUTPUT    LOOP              ;until    byte   count   low   (B  reg)   =  0
                         1313  OUT_DEC_HI_BYTE:                                          
                         1314                       DEC   D                              ;>byte  count    high   = byte    count   high    -  1
                         1315                       JR    NZ,OUTPUT    LOOP              ;until    byte   count   high   (A  reg)   =   O
                         1316                       RET                                  
                         1317  
                         1318  ;
                         1319  ;   Name:                   READ_VRAM
                         1320  ;
                         1321  ;   Function:               Reads from VRAM and puts the read data into a buffer area.
                         1322  ;
                         1323  ;   Entry:                  BC  - number of bytes to be read
                         1324  ;                           DE  - starting VRAM address to be read from
                         1325  ;                           HL  - address of buffer to receive the read data
                         1326  ;
                         1327  ;   Exit:                   None.
                         1328  ;
                         1329  ;   Registers      used:    AF,  BC,  DE,   HL
                         1330  ;
                         1331  ;   Size:                   ROM  - 22  bytes
                         1332  ;                           RAM  - O  bytes
                         1333  ;
                         1334  ;   Comments:               This  version of READ_VRAM is provided for stand alone operation.
                         1335  ;                           NOTE:  The 1OOH bug found in OS 7 has been corrected.
                         1336  ;
                         1337  ;   Comparision:            left  out pascal entry point
                         1338  ;                           code  compacted
                         1339  ;                           100H  bug fixed
                         1340  ;                           edited for documentation
                         1341  ;
                         1342  __READ_VRAM:                                              
                         1343                       PUSH  BC                             ;BC  has   the  number    of  bytes    to  xfer
                         1344                       EX    DE,HL                          ;HL<--vram     addr  ,DE<--source      address  .
                         1345                       CALL  SET READ                       ;pump   the  vram   addr    to  the   vdp
                         1346                       LD    L,C                            ;save   C  (the   data_port_  addr)
                         1347                       POP   BC                             ;restore    the   xfer  count
                         1348                       EX    DE,HL                          ;HL<--source      address,port       ine
                         1349                       LD    A,C                               :SAVE    LOW  ORDER    OF  COUNT    INA 
                         1350                       LD    C,E                            ;  And   get  the   port   into   C
                         1351                       LD    D,8                            ;Get   HI  order    count    in OD
                         1352                                                            ;  to  free   up  B  for   tow   order   count
                         1353                       INC   D                                  >INCREMENT     HI  COUNT   TO   COVER 
                         1354                                                            ;  for   O  tn  DEC  D  after    tow   loop
                         1355                       LD    B,A                            ;Put   low   order   in  86 for   OUTI
                         1356                       OR    A                              ;Check    if  tow   order   is   zero   the  first     time
                         1357                       JR    Z,IN_DEC_HI_BYTE               ;If   so  then   decrement     Hi  count    before     low   loop
                         1358  INPUT_LOOP:                                               
                         1359                       INI                                  ;DATA_PORT      = buffer   data      read   the  data     from   to    the   VDP
                         1360                                                            ;for   INI:   [C]}  <--  [HL],    B  =  B  -  1 amd    HL  =  HL   +   1
                         1361                       NOP                                  ;delay    for   slow   VDP
                         1362                       NOP                                  
                         1363                       JR    NZ,INPUT_LOOP                  ;until    byte   count   low   (B  reg)    = O
                         1364  IN_DEC_HI_BYTE:                                           
                         1365                       DEC   D                              ;byte   count    high   = byte    count    high   -   1
                         1366                       JR    NZ,INPUT_LOOP                   SUNTIL    BYTE   COUNT   HIGH    [A  REG]   =  O 
                         1367                       RET                                  
                         1368  
                         1369  ;
                         1370  ;   Name:                 WRITE_REGISTER
                         1371  ;
                         1372  ;   Function:             Writes a data byte vaiue to a desired VDP register
                         1373  ;
                         1374  ;   Entry:                B - register number to write to
                         1375  ;                         C - data byte value to be written
                         1376  ;
                         1377  ;   Exit:                 if register number = 0 or 1, the  respective byte
                         1378  ;                         of the VDP_MODE_WORD is updated.
                         1379  ;
                         1380  ;   Registers     used:   A,BC,E
                         1381  ;
                         1382  ;   Size:                ROM  - 27  bytes
                         1383  ;                         RAM - O  bytes
                         1384  ;
                         1385  ;   Comments:            This version    of  WRITE  REGITER      1s provided    for  stand    alone    operation.
                         1386  ;
                         1387  ;   Comparision:          left out  pascal    entry   point
                         1388  ;                        code  compacted
                         1389  ;                        edited   for  documentation
                         1390  
                         1391  __WRITE_REGISTER:                                         
                         1392                       LD    E,C                            ;Move   data  to  E— register
                         1393                       LD    A,[VDOP_CTRL_PORT]             ;Get  the  control    port    value
                         1394                       LD    C,A                            ;Put   in Cc
                         1395                       OUT   [C],E                          ;Output   data   value.
                         1396                       LD    A,B                            ;Get  port   #  INA
                         1397                       OR    80H                            ;Set  high   bit  for   277772?
                         1398                       OUT   [C],A                          ;Out  to  VOP
                         1399                       LD    A,B                            ;Get  back   port  value
                         1400                       OR    A                              ;Check   for  zero
                         1401                       LD    A,E                            ;Put  data   in  accumulator
                         1402  
                         1403                       JR    NZ,CHK_REG   1                 ;1f  not  zero   then   see   if  register     1
                         1404                       LD    [VDP_MODE_WORD],A              ;If  register    zero   was   written     to then
                         1405                                                            ; Save   data   in VDP_MODE    WORD
                         1406                       RET   SEXIT                          
                         1407  
                         1408  CHK_REG_1:                                                
                         1409                       DEC   B                              ;Check   for  register     1  in  B
                         1410                       RET   NZ                                -IF  NOT  THEN   RETURN 
                         1411                       LD    [VDOP_MODE  WORD+1],A             >IF  SO  THEN  STORE   DATA    IN  VOP_MODE    WORD?! 
                         1412                       RET   -EXIT                          
                         1413  
                         1414  
                         1415  
                         1416  ;     Name:                 READ_REGISTER
                         1417  ;
                         1418  ;     Function:             Reads a data byte value from the Colecovision CTRL_PORT.
                         1419  ;
                         1420  ;     Entry:                None.
                         1421  ;
                         1422  ;     Exit:                 A  -  data byte value read in
                         1423  ;
                         1424  ;     Registers used:       A,C
                         1425  ;
                         1426  ;     Size:                 ROM   -  3 bytes
                         1427  ;                           RAM   -  O  bytes
                         1428  ;
                         1429  ;     Comments:             This version of READ_REGISTER is provided for stand alone operation.
                         1430  ;                           This routine does a direct access to the COLECOVISION I/O ports.
                         1431  ;
                         1432  ;     Comparision:          edited for documentation
                         1433  ;
                         1434  __READ_REGISTER:                                          
                         1435                       LD    A,[VOP_CTRL_PORT]              
                         1436                       LD    C,A                            
                         1437                       IN    A,[C]                          ;get    the   data   from   CTRL_PORT
                         1438                       LD    [VOP_STATUS_BYTE],A            ;Save    a  copy    of  VDP   status    data
                         1439                       RET                                  
                         1440  
                         1441  
                         1442  ;
                         1443  ;   Name:               FILL_VRAM
                         1444  ;
                         1445  ;   Function:           Fill a VRAM memory buffer with a constant byte value.
                         1446  ;
                         1447  ;   Entry:              A - constant byte vaiue to be written
                         1448  ;                       DE - number of bytes in the VRAM memory buffer
                         1449  ;                       HL - starting VRAM address to be written to
                         1450  ;
                         1451  ;   Exit:               None.
                         1452  ;
                         1453  ;   Registers    used:  AF, C, DE
                         1454  ;
                         1455  ;    Size:               ROM - 18 bytes
                         1456  ;                        RAM - O bytes
                         1457  ;
                         1458  ;    Comments:           This version of FILL_VRAM is provided for stand alone operation.
                         1459  ;                        This routine does a direct access to the COLECOVISION I/O ports.
                         1460  ;
                         1461  ;    Comparision:        edited for documentation
                         1462  ;                        uneeded call to READ_REGISTER taken out
                         1463  
                         1464  
                         1465  FILL_VRAM:                                                
                         1466                       PUSH  AF                             ;Save the  data to fill with
                         1467                       CALL  SET_WRITE                      ;Sets the  ctrl port data and
                         1468                       POP   HL                             ;popping  AF into HL to restore the  fill  data
                         1469  FILL:                                                     ;repeat
                         1470                                                            ;  get back  a copy of the saved constant
                         1471                       OUT   [C],,H                         ;  write  the constant out to the VRAM  buffer
                         1472                       DEC   DE                             ;  byte  count = byte count - 1
                         1473                       LD    A,O                            ;until byte  count = O
                         1474                       OR    E                              
                         1475                       JR    NZ,FILL                        
                         1476                       RET                                  ;all done
                         1477  
                         1478  ;
                         1479  ;
                         1480  ;   Name:                  INIT_TABLE
                         1481  ;
                         1482  ;   Function:              INIT TABLE initializes the addresses of the VRAM tabies.
                         1483  ;                          The passed address is converted to the correct format needed
                         1484  ;                          to setup the VDP address registers. The following tabie codes
                         1485  ;                          are use to indentify which table address is being setup:
                         1486  ;
                         1487  ;                            O  - SPRITE ATTRIBUTE TABLE    (SAT)
                         1488  ;                            1  - SPRITE GENERATOR TABLE    (SGT)
                         1489  ;                            2  - PATTERN NAME TABLE        (PNT)
                         1490  ;                            3  - PATTERN GENERATOR TABLE   (PGT)
                         1491  ;                            4  - PATTERN COLOR TABEL       (PCT)
                         1492  ;
                         1493  ;   Entry:                A   -  table code (see above)
                         1494  ;                         HL  -  table address
                         1495  ;
                         1496  ;   Exit:                 None.
                         1497  ;
                         1498  ;   Registers     used:   AF,  BC,   HL,  IX,   IY
                         1499  ;
                         1500  ;   Size:                 ROM  -  99  bytes
                         1501  ;                         RAM  -  O  bytes
                         1502  ;
                         1503  ;   Comments:             This   version    of  INIT_TABLE    is  provided    for   stand   alone    operation.
                         1504  ;
                         1505  ;   Comparision:           jleft out  pascal    entry   point
                         1506  ;                         code  compacted
                         1507  ;                         edited   for   documentation
                         1508  ;
                         1509  __INIT_TABLE:                                             
                         1510  
                         1511                       LD    C,A                            
                         1512                       LD    B,0                            
                         1513                       LD    IX,VRAM_ADDR_TABLE             ;point    to  start   of  VRAM_ADOR_TABLE
                         1514                       ADD   IX,BC                          ;add   in  the   index
                         1515                       ADD   IX,BC                          
                         1516                       LD    [IXX+0],L                      ;save   the  address
                         1517                       LD    [IX+1],H                       
                         1518                                                            ;CHECK   VDP   GRAPHICS    MODE
                         1519                       LD    A,[VDP_MODE    WORD]           ;'f  VDOP_MODE  WORD    bit   t   mode   bit   3   =  1
                         1520                       BIT   1,8                            
                         1521                       JR    Z,INIT_TABLE8O                 
                         1522                                                            ;   ts   graphics     mode   2,  look   for   PGT  or  PCT   first
                         1523                       LD    A,C                            ;   get  the   table   code
                         1524                       CP    3                              ;   if  table   code   =  PGT
                         1525                       JR    Z,CASE  OF  GEN                ;      then  setup   PGT   address
                         1526                       CP    4                              ;      {f  table   code   = PCT
                         1527                       JR    Z,CASE  OF  COLOR              ;      then  setup   PCT   address
                         1528                       JR    INIT  TABLE8O                  ;     else   not   a special     case,   use   normal   setup
                         1529  
                         1530  ;
                         1531  ; special    case:   graphics   mode   2,  address    of  PGT
                         1532  ;
                         1533  CASE_OF_GEN:                                              
                         1534                       LD    B,4                            ;register   mumber  *  PGT   base  address    register
                         1535                       LD    A,L                            ;if  PGT  address  =  QOOOH                                                                      
                         1536                       OR    H                              
                         1537                       JR    NZ,CASE_OF_GEN_IO              
                         1538                       LD    C,3                            ;   data  byte  value  for   address   OOOOH
                         1539                       JR    INIT_TABLES0                   
                         1540  CASE_OF_GEN_IO:                                           ;else    PGT address   <>  OOOOH
                         1541                       LD    C,7                            ;   data  byte  value  for   address   2000H
                         1542                       JR    INIT_TABLES90                  ;endif
                         1543  ;
                         1544  ; special    case:   graphics   mode   2,  address    of  PCT
                         1545  ;
                         1546  CASE_OF_COLOR:                                            
                         1547                       LD    8,3                            ;register   number  =  PCT   base  address    register
                         1548                       LD    AL                             ;if  PCT  address  =  QOOQOH
                         1549                       OR    H                              
                         1550                       JR    NZ,CASE   OF  CLR10            
                         1551                       LD    C,7FH                          ;   data  byte  value  for   address   OOOOH
                         1552                       JR    INIT_TABLE90                   
                         1553  CASE_OF_CLRIO:                                            ;else    PCT address   <>  OOOOH
                         1554                       LD    C,OFFH                         ;   Gata  byte  value  for   address   2000H
                         1555                       JR    INIT_TABLE90                   ;endif
                         1556  ;
                         1557  ; not  a  special    case  (i.e.  not   mode   2,  PGT  or    PCT)
                         1558  ;
                         1559  INIT_TABLE8O:                                             ;base   address  = table   address    /  factor
                         1560                       LD    IY,BASE  FACTORS               ;potnt   to start  of  the   the  factor   table
                         1561                       ADD   IY,BC                          ;index   into the  table   by  the  table    code
                         1562                       ADD   IY,6C                          
                         1563                       LD    A,[IY+0]                       ;get  the  shift  count
                         1564                       LD    B,[IY+1]                       ;get  the  register   number
                         1565  DIVIDE:                                                   
                         1566                       SRL   H                                  :SHIFT   HI-BYTE 
                         1567                       RR    L                                  :SHIFT   LO-BYTE 
                         1568                       DEC   A                              ;shift   count  = shift   count   -  1
                         1569                       JR    NZ DIVIDE                      
                         1570                       LD    C,L                                :GET  THE  DATA  BYTE  VALUE 
                         1571  INIT_TABLE90:                                             
                         1572                       CALL  WRITE_REGISTER                 ;setup   the base  register
                         1573                       RET                                  
                         1574  
                         1575  ;
                         1576  ; base factor  table, used  to calculate base  addresses
                         1577  ;
                         1578  BASEFACTORS:                                              
                         1579                       DEFB  7                              ;table code O base factor
                         1580                       DEFB  5                              ;register 5, SAT base address
                         1581                       DEFB  11                             ;table code 1 base factor
                         1582                       DEFB  6                              ;register 6, SGT base address
                         1583                       DEFB  10                             ;table code 2 base factor
                         1584                       DEFB  2                              ;register 2, PNT base address
                         1585                       DEFB  11                             ;table code 3 base factor
                         1586                       DEFB  4                          :REGISTER 4,PGT BASE ADDRESS 
                         1587                       DEFB  6                              ;table code 4 base factor
                         1588                       DEFB  3                              ;register 3, PCT base address
                         1589  
                         1590  ;
                         1591  ;   Name:                PUT_VRAM
                         1592  ;
                         1593  ;   Function:            Gets a block of data from a user buffer and puts it into VRAM.
                         1594  ;                        The following table codes are used to identify which VRAM table
                         1595  ;                        is being referenced:
                         1596  ;
                         1597  ;                          O  - SPRITE ATTRIBUTE TABLE      (SAT)
                         1598  ;                          1  - SPRITE GENERATOR TABLE      (SGT)
                         1599  ;                          2  - PATTERN NAME TABLE          (PNT)
                         1600  ;                          3  - PATTERN GENERATOR TABLE     (PGT)
                         1601  ;                          4  - PATTERN COLOR TABLE         (PCT)
                         1602  ;
                         1603  ;   Entry:               A  -  table code (see above)
                         1604  ;                        DE -  starting index into the table
                         1605  ;                        Hi -  address of user buffer
                         1606  ;                        IY -  block size (or byte count)
                         1607  ;
                         1608  ;   Exit:                None.
                         1609  ;
                         1610  ;   Registers    used:   AF, DE, HL, IY
                         1611  ;
                         1612  ;   Routines    used:    SET_COUNT
                         1613  ;
                         1614  ;   Size:                ROM -  O bytes
                         1615  ;                        RAM -  O bytes
                         1616  ;
                         1617  ;   Comments:            This version of PUT_VRAM is provided for stand alone operation.
                         1618  ;
                         1619  ;   Comparision:         left out pascal entry point
                         1620  ;                        took out the mux sprites capablity
                         1621  ;                        code compacted
                         1622  ;                        edited for documentation
                         1623  ;
                         1624  __PUT_VRAM:                                               
                         1625                       CALL  SET COUNT                      ;setup    the  actual    byte   count   and  the  absolute VRAM  address
                         1626  ;*                   CALL     WRITE  VRAM                      ;VRAM    data  =  user   buffer
                         1627  ;+                   RET
                         1628                       JP    WRITE  VRAM                    
                         1629  
                         1630  
                         1631  
                         1632  ;   Name:             GET_VRAM
                         1633  ;
                         1634  ;   Function:         Gets a block of data from VRAM and stores it into a user buffer.
                         1635  ;                     The following table codes are used to identify which vRAM table
                         1636  ;                     is being referenced:
                         1637  ;
                         1638  ;                       O - SPRITE ATTRIBUTE TABLE   (SAT).
                         1639  ;                       1 - SPRITE GENERATOR TABLE   (SGT)
                         1640  ;                       2 - PATTERN NAME TABLE       (PNT)
                         1641  ;                       3 - PATTERN GENERATOR TABLE  (PGT)
                         1642  ;                       4 - PATTERN COLOR TABEL      (PCT)
                         1643  ;
                         1644  ;   Entry:            A - table code (see above)
                         1645  ;                     DE - starting index into the table
                         1646  ;                     HL - address of user buffer
                         1647  ;                     IY - block size (or byte count)
                         1648  ;
                         1649  ;   Exit:             None.
                         1650  ;
                         1651  ;   Registers  used:  AF, DE, HL, IY
                         1652  ;
                         1653  ;   Routines  used:   SET_COUNT
                         1654  ;
                         1655  ;   Size:             ROM - O bytes
                         1656  ;                     RAM - O bytes
                         1657  ;
                         1658  ;   Comments:         This version of GET_VRAM is provided for stand alone operation.
                         1659  ;
                         1660  ;   Comparision:      left out pascal entry point
                         1661  ;                     code compacted
                         1662  ;                     edited for documentation
                         1663  
                         1664  __GET_VRAM:                                               
                         1665                       CALL  SETCOUNT                       ;setup  the actual byte count and the  absolute VRAM  address
                         1666                       CALL  READ_VRAM                      ;user buffer  = VRAM data
                         1667                       RET                                  
                         1668                       JP    READ_VRAM                      
                         1669  
                         1670  ;
                         1671  ;  CALLED     BY   PUT_VRAM_     AND  GET  VRAM_
                         1672  ;
                         1673  ; SETS     BYTE   COUNT    AND  INDEX   FOR   WRITES     TO  AND   READS   FROM   VRAM.
                         1674  ;
                         1675  ;   TABLE                BYTES/ITEM
                         1676  ;   SPRITE   NAME               4
                         1677  ;   SPRITE   GEN                8
                         1678  ;   PATTERN    NAME             1
                         1679  ;   PATTERN    GEN              #
                         1680  ;   COLOR    (MODE     1)       1
                         1681  ;   COLOR    (MODE    2)        a
                         1682  ;
                         1683  SET_COUNT                                                 
                         1684                       PUSH  IY                             ;Save   count   on  stack
                         1685                       LD    C,A                            ;Get  table   code    4
                         1686                       CP    4                              ;See   if color    table
                         1687                       JR    NZ,NOT   COLOR   TBL_ACCESS    ;If  not   then  check    for  name    table
                         1688                                                            ;Color   Table
                         1689                       LD    A,[VOP_MODE    WORD]           ;Get   mode   word   to  check    graphics     type
                         1690                       AND   02H                            ;Bit    1 indicates     mode   i  or  2
                         1691                       JR    Z,ADD_TO_  BASE                ;If   mode   1  then  start    index    is  not   modif   ted
                         1692                       LD    A,C                            ;Get   table   code   back
                         1693                                                            ;Fall    through    to  multiply     by  8  for   mode   2.
                         1694  NOT_COLOR_TBL_ACCESS                                      
                         1695                       CP    2                              ;Check    for  Name    table
                         1696                       JR    Z,ADD  TO  BASE                ;If   so  then   don’t   modify    start    index
                         1697                                                            ;At   this  point    the   table   code    is:
                         1698                                                            ;   Sprite   attribute      table,    Sprite    gen   table,
                         1699                                                            ;  Pattern    gen   table,   or   Color   table     in  Mode   2
                         1700  
                         1701                       EX    DE,HL                              -GET   COUNT    IN HL 
                         1702                       ADD   HL,HL                          ;*2
                         1703  
                         1704                       ADD   HL,HL                          ;*4
                         1705                       OR    A                              ;Check    for  Sprite    attr   table
                         1706                       JR    Z,HAVE_CNT                     ;If   so  then   Index*4    is  complete
                         1707                       ADD   HL,HL                          ;If  not   then   Index*8     is  required
                         1708                                                            ;  this   is  for   the  pattern    gen   table,
                         1709                                                            ;  sprite   gen   table,    or  color    gen   table
                         1710                                                            ;  in  mode   2.
                         1711  HAVE_CNT:                                                 
                         1712                       EX    DE,HL                          ;Put   updated    index    in  DE
                         1713                       EX    [SP],HL                        ;Get   count   off   stack
                         1714                                                            ;Put  address    of  RAM   buffer    on  stack
                         1715  
                         1716                                                            ;Now   modify    the  count    for:
                         1717                                                            ;  Sprite   attribute      table,   Sprite     gen   table,
                         1718                                                            ;  Pattern    gen   table,   or   Color   table     in  Mode   2
                         1719                       ADD   HL,HL                          
                         1720                       ADD   HL,HL                          
                         1721                       JR    Z,HAVE_CNT2                    ;If  Sprite    attr   table    then   +4  {is  enoungh
                         1722                                                            ;  (the   zero   flag   is  still   set   from    earlier)
                         1723                       ADD   HT,HL                          ;Count    *8  for  remaining      tables
                         1724  HAVE_CNT2:                                                
                         1725                       EX    [SP],HL                        ;Save   updated    count    on  stack
                         1726                                                            ;Restore    RAM   buffer    off   stack
                         1727  ADD_TOBASE:                                               
                         1728                       LD    A,C                            ;Get table code back
                         1729                       LD    BC,VRAMADDR_ TABLE             ;Get top of address table
                         1730                       PUSH  HL                             ;Save RAM buffer on stack
                         1731                       LD    H,OOH                          ;Put table code tnto HL
                         1732                       LD    L,A                            
                         1733                       ADD   HL,HL                          ;*2 to offset for addresses   in table
                         1734                       ADD   HT,BC                          ;Add to top of table
                         1735                       LD    A,[HL]                         ;Low byte of VRAM table address
                         1736                       INC   HL                             
                         1737                       LD    H,[HL]                         ;High byte of VRAM table  address
                         1738                       LD    L,A                            
                         1739                       ADD   HL,DE                          ;Add offset from start of  table
                         1740                       EX    DE,HL                          ;Absolute VRAM address  in DE
                         1741                       POP   HL                             ;Restore RAM buffer address
                         1742                       POP   BC                             ;Restore Count into BC
                         1743                                                            ;Registers are now ready  for
                         1744                                                            ; a call to the basic READ/WRITE   VRAM routines
                         1745                       RET                                  ;Exit
                         1746  
                         1747  ;*******************      CALC  OFFSET    *****************************************************************
                         1748  ;
                         1749  ;DESCRIPTION:         THIS ROUTINE CALCULATES THE PROPER OFFSET INTO THE NAME TABLE
                         1750  ;                     FOR THE PATTERN POSITION GIVEN BY X PAT_POS, Y_PAT_POS. THE
                         1751  ;                     FORMULA USED IS:   OFFSET =  32*Y_PAT_POS + XPAT_POS
                         1752  ;
                         1753  ;INPUT:               D  =   X_PAT_POS
                         1754  ;                     E  =   Y_PaT_POS
                         1755  ;
                         1756  ;OUTPUT  -            DE =   OFFSET
                         1757  ;
                         1758  ;**********************************************************************************************************
                         1759  ;
                         1760  __CALC_OFFSET:                                            
                         1761                       PUSH  HL                             ;save   HL
                         1762                       BIT   7,D                            ;1f   Y_PAT  POS     is minus
                         1763                       JR    Z,ELSE_11                      
                         1764                       LD    H,OFFH                         ;   extend     negative    sign
                         1765                       JR    END_IF_11                      
                         1766  ELSE_11:                                                  ;else
                         1767                       LD    H,O                            ;   extend     positive    sign
                         1768  END_IF_11:                                                ;endif
                         1769  
                         1770                       LD    L,D                            ;OFFSET    =   32*Y PAT   POS    + X PAT   POS
                         1771                       ADD   HL,HL                            SHL=2*Y   PAT   POS 
                         1772                       ADD   HL HL                          ;     4+     .
                         1773                       ADD   HL,HL                            >     OF     * 
                         1774                       ADD   HL,HL                          ;   16       .
                         1775                       ADD   HL,HL                             > ; 32s      °
                         1776  
                         1777                       BIT   7,€                               > 1F  X_PAT_POS     IS  MINUS 
                         1778                       JR    Z,ELSE_12                      
                         1779                       LD    D,OFFH                             > ; extend    negative     sign
                         1780                       JR    END_IF_12                      
                         1781  ELSE_12:                                                  ;else
                         1782                       LD    0,0                            ;   extend    positive     sign
                         1783  ENO_IF_12:           endif                                
                         1784  
                         1785                       ADD   HL,DE                          ;HL=32¢Y   PAT    POS   +  XPAT_POS
                         1786                       EX    DE,HL                          
                         1787                       POP   HL                             ;restore    HL   intact
                         1788                       RET                                  
                         1789  
                         1790  ; ********************    PX TO.PTRN.  POS  ***************************************
                         1791  ;DESCRIPTION:       DIVIDES REG DE BY 8, IF SIGNED RESULT > 127 THEN E :=  MAX SIGNED
                         1792  ;                   POSITIVE NUMBER.  IF RESULT < -128,  THEN  E := MIN NEGATIVE NUM
                         1793  ;INPUT:              DE =  16  BIT SIGNED  NUMBER
                         1794  ;OUTPUT:             DE/8 < -128       E =  -128
                         1795  ;        -128   <= DE/8   <=+127      E  = DE/8
                         1796  ;        +127   <  DE/8               E  = +127
                         1797  ; *********************************************************************************
                         1798  ;
                         1799  __PX_TO_PTRN_POS:                                         
                         1800  
                         1801                       PUSH  HL                             ;HL  USED  TO  TEST  MAGNITUDE
                         1802  ;
                         1803                       PUSH  BC                             ;B  WILL  BE  USED  AS  A  COUNTER   IN  THE   DIVIDE
                         1804                       LD    B,3                            
                         1805  PX_2_P_P_1:                                               ;(THIS   IS  THE START   OF  THE   DIVIDE   LOOP)
                         1806                       SRA   D                              ;16  BIT  SHIFT  LEFT
                         1807                       RR    E                              
                         1808                       DJNZ  PX_2 P_P_1                     ;DIVIDE   BY  8 LOOP
                         1809                       POP   BC                             ;RESTORE   BC  TO  OLD  VALUE
                         1810  ;
                         1811                       LD    HL,OFF80H           -SET   HL TO  -128 
                         1812                       BIT   7,0                            ;1S  RESULT   OF DIVIDE    NEGATIVE?
                         1813                       JR    NZ,NEGTV                       
                         1814  ;
                         1815                       ADD   HL,DE                >IF DE-128   < O  [FRNC]  RETURN 
                         1816                       POP   HL                   -SAME   AS [IF  DE<=127    RETURN] 
                         1817                       RET   NC                             
                         1818                       LD    E,7FH                          ;1F  >  128,  THEN  E  >=  MAX  SIGNED   +  NUM.
                         1819                       RET                                  
                         1820  ;
                         1821  NEGTV:               LD    H,OOH                          ;SET   HL TO  128
                         1822  ;
                         1823                       ADD   HL,DE                IF  DE+128   >= O  RETURN 
                         1824                       POP   HL                             ;same   as (IF  DE>=-128    RETURN)
                         1825                       RET   C                              
                         1826                       LD    E,80H                          ;IF  <  -128,  THE  E      MIN  SIGNED   -  NUM.
                         1827                       RET                                  
                         1828  
                         1829  DEL                  EQU   7FH                            ;ASCII code for   it
                         1830  ;ASCII_GEN          EQU      LOC_INALPHA      ist byte of  generator  for  NUL
                         1831  ;
                         1832  ; _LOAD_ASCII
                         1833  ;
                         1834  ;     Loads the ASCII character generators into VRAM at the
                         1835  ;     current pattern generator table (NOTE - INIT_TABLE must
                         1836  ;     have been called prior to this).  Only the characters
                         1837  ;     from the space to the DEL (20h to 7Fh) are loaded.
                         1838  ;
                         1839  ;Input   Parameters:
                         1840  ;   NONE
                         1841  ;
                         1842  ;Returns:
                         1843  ;   A, 8C, HL, DE are destroyed
                         1844  ;
                         1845  ;  Falls into _PUT_ASCII
                         1846  ;
                         1847                                                            ;
                         1848                                                            ;LO       HL,[PATTRNGENTBL];get base of  current  generator    table
                         1849                       LD    DE,[PATTRNGENT8L]              ;get base of  current  generator    table
                         1850                                                            ;LD       DE,00H+8        ;Offset into  it where  SPACE  will   be
                         1851                                                            ;ADD      HL.DE
                         1852                                                            ;EX       DE.HL           ;leave VRAM address   in DE
                         1853                       LD    HL,00H                         ;want to start  with  the null
                         1854                       LD    BC,[DEL-00H+1]                 ;load the entire  ASCII  set (0. .7F)
                         1855  ;
                         1856  ; fall   thru to  PUT_ASCII
                         1857  ;:
                         1858  
                         1859  ;
                         1860  ;  __PUT_ASCII
                         1861  ;
                         1862  ;       Copys a specified number of ASCII character generators into VRAM.
                         1863  ;       Swaps to ROM that contains the generators then swaps back, keeps
                         1864  ;       track of callers stack and uses a local stack that is known to
                         1865  ;       be in RAM when the ROM is swapped in.
                         1866  ;
                         1867  ;Input  Parameters:
                         1868  ;  HL  - Character to 1st  load (generally in range O..FFH)
                         1869  ;  BC  - Number of characters to load  (Not the number of bytes)
                         1870  ;  DE  - Address in VRAM  to load the 1st generator
                         1871  ;
                         1872  ;  A,  BC, HL,  DE, IX  are  destroyed
                         1873  ;
                         1874  ;  Calis  WRITE_VRAM
                         1875  ;         SWITCH_MEM
                         1876  ;
                         1877  
                         1878                       ADD   HL,HL                          ;multiply  char  to  start  loading  by  8
                         1879                       ADD   HL,HL                          ;SO  can use  it as  an offset   into the
                         1880                       ADD   HT HL                          ;ASCII  generator
                         1881                       PUSH  BC                             ;save  number  of chars   desired
                         1882                                                            ;LD       BC,ASCII_GEN
                         1883                                                            ;LD       BC,([LOC_IN_ALPHA})
                         1884                                                            ;ADD      HL.BC              ;now HL points   to the  ist generator    desired
                         1885                       EX    [SP],HL                        ;get  number  of chars  desired
                         1886                       ADD   HL,HL                          ;and  multiply  by  8
                         1887                       ADD   HL,HL                          ;   since each  generator   is 8  bytes
                         1888                       ADD   HL,HL                          ;      long
                         1889                       EX    [SP],HL                        ;get  back pointer   into  ASCII  generators
                         1890                       POP   BC                             ;get  number  of chars  times  8
                         1891  
                         1892                       LD    IX,OOOOH                       ;   to use to  save  callers  SP
                         1893                       ADD   IX,SP                          
                         1894                       LD    SP,TEMP_STACK                  ;set  stack  into known  RAM
                         1895                       PUSH  IX                             ;save  callers  SP
                         1896  
                         1897                       LD    A,[CUR_BANK]                   ;remember  which  bank  setting   we
                         1898                       PUSH  AF                             ;    are in
                         1899                       LD    A,[MEM_CNFGOO]                 ;get  value  to let  us get  at the  ALPHA   roms
                         1900  
                         1901                       PUSH  BC                             ;count  would  get  destroyed  by  SWITCH MEM
                         1902                       CALL  SWITCHMEM                      
                         1903                       POP   BC                             
                         1904  
                         1905                       PUSH  DE                             
                         1906                       LD    DE,[LOC_IN_ ALPHA]             
                         1907                       ADD   HL,DE                          
                         1908                       POP   DE                             
                         1909  
                         1910                       CALL  WRITE_VRAM                     
                         1911  
                         1912                       POP   AF                             ;get  back callers   mem configuration
                         1913                       CALL  SWITCH_MEM                     
                         1914  
                         1915                       POP   HL                             ;get  callers  SP
                         1916                       LD    SP,HL             -AND RESTORE IT 
                         1917                       RET   >                              ;and back to  caller
                         1918  
                         1919  ;
                         1920  ;    Switch_mem:  memory bank switching routine
                         1921  ;
                         1922  ;    Inputs:
                         1923  ;                 A = Appropriate input from  SWITCH TABLE
                         1924  ;
                         1925  ;                  Example:
                         1926  ;     Switch Table  Offset    Memory  configuration
                         1927  ;    *************************************************************************
                         1928  ;
                         1929  ;             0 -          Boot ROM and Alpha Roms
                         1930  ;             1 -          Intrinsic RAM (OOOOH  thru 7FFFH)
                         1931  ;             2 -          Expansion memory (OOOOH thru 7FFFH)
                         1932  ;             3 -          OS_7 and Intrinsic RAM (2000H thru 7FFFH)
                         1933  ;             4
                         1934  ;             .
                         1935  ;             D
                         1936  ;             E
                         1937  ;             F
                         1938  ;
                         1939  ;   *** Note: The values in the table are subject to change in future
                         1940  ;             releases of ADAM  hardware.
                         1941  ;
                         1942  ;   For an example  of the use  of SWITCH MEM   see PORT COLLECTION    below.
                         1943  ;
                         1944  ;
                         1945  ;    Outputs:
                         1946  ;                  CUR_BANK, a defined memory location will contain
                         1947  ;                  the updated input parameter for applications and
                         1948  ;                  EOS routines which need to determine  which
                         1949  ;                  memory space is currently active.
                         1950  
                         1951  __SWITCH_MEM                                              
                         1952                       LD    B A                            ;SAVE THE  PORT DATA   TO WRITE
                         1953                       LD    A [MEMSWITCH  PORT]            ;GET THE  PORT NUMBER
                         1954                       LD    CCA                            
                         1955                       OUT   [CJ»B                          ;SWITCH  MEMORY BANKS
                         1956                       LD    AB                             
                         1957                       LD    [CUR_BANK],A                   ;REMEMBER  WHAT WAS   SWITCHED  TO.
                         1958                       RET                                  
                         1959  ;
                         1960  ;
                         1961  ;    Port collection must be calied during initialization
                         1962  ;    It switches to OS7 ROM grabs the ports and switches back
                         1963  ;
                         1964  
                         1965  PORT_COLLECTION:                                          
                         1966                       LD    A,[CUR_BANK]                   ;GET THE CURRENT BANK
                         1967                       PUSH  AF                             
                         1968  ;
                         1969                       LD    A,[MEMCNFGO3]                  ;SWAP IN THE OS
                         1970                       CALL  SWITCH_MEM                     
                         1971                       LD    HL,PORTTABLE+2                 ;HL POINTS TO THE PORT   TABLE
                         1972  ;
                         1973                       LD    A,[01043H]                     ;VDP CONTROL PORT
                         1974                       LD    [HL],A                         
                         1975                       INC   HL                             
                         1976  ;
                         1977                       LD    A,[01D47H]                     ;VDP DATA PORT
                         1978                       LD    [HL],A                         
                         1979                       INC   HL                             
                         1980  ;
                         1981                       LD    A,[0114BH]                     ;CONTROLLER O
                         1982                       LD    [HL],A                         
                         1983                       INC   HL                             
                         1984  ;
                         1985                       LD    A,[01151H]                     ;CONTROLLER 1
                         1986  .                    LD    [HL],A                         
                         1987                       INC   HL                             
                         1988  ;
                         1989                       LD    A,[01157H]                     ;CONTROLLER STROBE SET
                         1990                       LD    [HL],A                         
                         1991                       INC   HL                             
                         1992  ;
                         1993                       LD    A,[01168H]                     ;CONTROLLER STROBE RESET
                         1994                       LD    [HL],A                         
                         1995                       INC   HL                             
                         1996  ;
                         1997                       LD    A,[O018EH]                     ;SOUND PORT
                         1998                       LD    [HL],A                         
                         1999                       POP   AF                             
                         2000                       CALL  SWITCH_MEM                     
                         2001                       RET                                  
                         2002  
                         2003  ;
                         2004  ;  Name:              WR_SPR_ATTRIBUTE
                         2005  ;
                         2006  ;  Function:          Transfers the local copy of the sprite attribute table
                         2007  ;                     to VRAM.   WR_SPR_ATTRIBUTE will also reorder the
                         2008  ;                     sprite table to reduce 5th sprite priority problems.
                         2009  ;
                         2010  ;  Entry:             DE - address of Local Sprite Table
                         2011  ;                     HL - address of Priority table
                         2012  ;                      A - number of sprites to be transfered (length of Local Sprite
                         2013  ;                            table divided by 4
                         2014  ;  Exit:              None.
                         2015  ;
                         2016  ;  Registers   usec:  AF, BC,  DE, Hi.
                         2017  ;
                         2018  ;  Data   structures  accessed:
                         2019  ;                     VRAM_ADDR_TABLE   (SPRITEATTRIBL)   for the starting     address
                         2020  ;                     of the  sprite  attribute  table  in VRAM.
                         2021  ;
                         2022  ;                     PORT PTR_TABLE   (CTRL_PORT_ PTR,  DATAPORT_PTR)     for
                         2023  ;                     VDP port  access.
                         2024  ;
                         2025  ;                     Local  Sprite  Table  - User defined  memory  image   of
                         2026  ;                     the sprite  attribute   table
                         2027  ;
                         2028  ;                     Priority  Table  - User  defined  sprite priority    list
                         2029  ;                     for the  transfer  of  the sprite  attributes
                         2030  ;
                         2031  ;  Size:              ROM  - xx bytes
                         2032  ;                     RAM  - xx bytes
                         2033  ;
                         2034  ;  Comments:
                         2035  ;
                         2036  ;  Comparision:       left out  pascal  entry  point
                         2037  ;                     added  register  parameters   in place of defined    memory  pointers
                         2038  ;                     code compacted
                         2039  ;                     edited  for documentation
                         2040  ;
                         2041  _WR_SPR_ATTRIBUTE                                         
                         2042  ;                                                      Initialize  VOP  address    pointer
                         2043                       PUSH  AF                             
                         2044                       PUSH  HL                             
                         2045                       LD    HL,[SPRITEATTRTBL ]            
                         2046                       CALL  SET_WRITE                      
                         2047                       POP   HL                             
                         2048                       POP   AF                             
                         2049                       LD    B,A                            
                         2050                                                            ;-B = Sprite Count
                         2051                                                            ;-C = port address
                         2052                                                            ;-DE = address  of  Local   Sprite   Attribute  Table
                         2053                                                            ;-HL = address  of  Priority   table
                         2054                                                            ;-VDOPis initialized    to  appropriate    address
                         2055  
                         2056  LOOP_EVERYSPRITE:                                         
                         2057  
                         2058  ;*                Index  to sprite   with the next  highest  priority
                         2059  
                         2060                       LD    A,[HL]                         ;Get current sprite   as defined  by the  priority table
                         2061                       ADD   A,A                            ;*2 Multiply by  an  attribute  entry (4)
                         2062                       ADD   A,A                            ;*4
                         2063  
                         2064                       INC   HL                             ;Index to next  location   in priority table
                         2065                       PUSH  HL                             ;Save for next  sprite
                         2066  
                         2067                       LD    L,A                            ;Offset into the  Local  Sprite  Table by  the current priority
                         2068                       LD    H,O                            
                         2069                       ADD   HL,DE                          
                         2070  
                         2071  
                         2072                       LD    A,B                            ;Save sprite count   tm Acc.
                         2073                       LD    8,4                            ;Set count for  write  to VRAM
                         2074                                                            ;C has port address
                         2075                                                            ;HL has the pointer   to a sprite’s  attributes
                         2076  LOOPEVERY            BYTE                                 
                         2077                       OUTI                                 ;Output a byte
                         2078                       NOP                                  ;Wait for VDP to  catch  up  (worst case)
                         2079                       NOP                                  
                         2080                       JR    NZ,LOOP_EVERY  BYTE            
                         2081  
                         2082                       LD    B,A                            ;Restore sprite  count  to 8B register
                         2083                       POP   HL                             ;Restore index  into  the priority  table
                         2084                       DJNZ  LOOP_EVERY SPRITE              ; If more sprites   left then  loop back
                         2085  
                         2086                       RET                                  ;Else exit
                         2087  
                         2088  ;
                         2089  ; Name:       SET_READ / SET_WRITE
                         2090  ;
                         2091  ; Function:   Initiates the VDP for read or writes.
                         2092  ;
                         2093  ; Entry:      HL - VRAM  address to start read / writes
                         2094  ;
                         2095  ; Exit:       C register contains the VDP_DATA_PORT value
                         2096  ;             HL remains unchanged
                         2097  ;
                         2098  ; Registers used: AF, BC, HL,
                         2099  ;
                         2100  ; Data structures accessed:
                         2101  ;
                         2102  ;             PORT_TABLE (CTRL_PORT_PTR, DATA_PORT_PTR) for
                         2103  ;                    VDP  port access.
                         2104  ;
                         2105  ; Size:       ROM - xx bytes
                         2106  ;             RAM - xx bytes
                         2107  ;
                         2108  ; Comments:
                         2109  ;
                         2110  ; Comparison:
                         2111  ;
                         2112  SET_READ:                                                 
                         2113                       XOR   A                              ;Clear accumulator  for later OR  which
                         2114                                                            ; Getermines a  read or write
                         2115  
                         2116                       DEFB  OC2H              :THIS IS THE BEGINNING  OF A JP  NZ WHICH 
                         2117                                                            ; will never be  true but leaves  the
                         2118                                                            ; accumulator  intact over the  next
                         2119                                                            ; two bytes (  the LD A,40H  is decoded
                         2120                                                            ; as the last  two bytes of the  jump
                         2121  SETWRITE:                                                 
                         2122                       LD    A,40H                          ;Set bit to tell  VDP that write  is requested
                         2123  
                         2124                       LD    BC,[VDP_CTRL_PORT]             ;Get BOTH port  addresses
                         2125                       OUT   [C],L                          ;Output low 8 bits  of address
                         2126                       OR    4H                             ;OR read/write  bit (Bit 6) into  the high    8 bytes
                         2127                       OUT   [CJ,A                          ;Output result
                         2128                       LD    C,B                            ;Put DATA_PORT  value into the  C register
                         2129  
                         2130                       RET                                  ;Exit to caller
                         2131  
                         2132  ;CONTROLLER SOFTWARE
                         2133  ;
                         2134  ;**********************************************
                         2135  ;*
                         2136  ;*  DECODER TABLE FOR  THE  KEYBOARD
                         2137  ;*
                         2138  ;**********************************************
                         2139  DEC_KBD_TBL                                               
                         2140                       DEFB  KBD_NULL                       ; NULL ENTRY
                         2141                       DEFB  6                              ; *°6’
                         2142                       DEFB  1                              ; ft’
                         2143                       DEFB  3                              ; °3°
                         2144                       DEFB  9                              ; *9’
                         2145                       DEFB  O                              ; °O’
                         2146                       DEFB  10                             ; fe!
                         2147                       DEFB  12                             ; Purple Action  Controller  key (third  one down)
                         2148                       DEFB  2                              ; °2°
                         2149                       DEFB  11                             ; fw?
                         2150                       DEFB  7                              ; ‘7’
                         2151                       DEFB  13                             ; Blue Action  Controller  key (fourth  (or last)  one down
                         2152                       DEFB  5                              ; ‘5’
                         2153                       DEFB  4                              ; 14!
                         2154                       DEFB  8                              ; ‘8’
                         2155                       DEFB  KBDO_NULL                      ; NULL ENTRY
                         2156  
                         2157  KBD_NULL             EQU   0FH                            
                         2158  KBD_MASK             EQU   0FH                            ;MASK  FOR  INPUT DATA BYTE
                         2159  FIREMASK             EQU   40H                            
                         2160  ARM_MASK             EQU   40H                            
                         2161  JOY_MASK             EQU   0FH                            
                         2162  
                         2163  
                         2164  
                         2165  __DECODER                                                 
                         2166  ;           Will read all the data, from both segments, for a given  controller
                         2167  ;           All data  isreturned in regtsters          .
                         2168  ;           Segment O data is returned the same as with 0S-7
                         2169  ;
                         2170  ;     NOTE - some operations are done in an odd order so that a certain
                         2171  ;            number of cycles (T states) pass between port addressing.
                         2172  ;            Turns off interupts if they were on at entry time for
                         2173  ;            195 T states (approx. 54.5 micro secs), the iterupts
                         2174  ;            are reenabled after this time if they were on before.
                         2175  ;
                         2176  ;     Callers  -  The input parameters are different than 0OS-7and
                         2177  ;                 both segments are returned so only one call is  required
                         2178  ;                 for all the data from a given controller.
                         2179  ;                 The values returned are the same for segment O  (H, L,  E)
                         2180  ;                 but segment 1 values are returned in B and OD.
                         2181  
                         2182  ;StackUsage:
                         2183  ; Uses 2 words (pushes only)
                         2184  ;
                         2185  ;Input Parameters:
                         2186  ;   A  - controller number, O or 1
                         2187  
                         2188  ;Returns:
                         2189  ;    H  - fire button data
                         2190  ;    L  - joystick data
                         2191  ;    6  - arm button data
                         2192  ;    C  - raw data for segment O, (joystick, fire)
                         2193  ;    D  - keyboard data
                         2194  ;    E  - spinner count data
                         2195  ;    A  - raw data for segment 1, (keyboard, arm, super controller  buttons)
                         2196  ;
                         2197  ;    SPIN SWxCT   - reset to O after read
                         2198  ;
                         2199  ;    strobe port left in the reset condition
                         2200  ;
                         2201  ;-Date:
                         2202  ; 9/24/83   11:14    JKL
                         2203  ;
                         2204  
                         2205  DECODER:                                                  
                         2206                       LD    CA                             ;Save   controller      #
                         2207                       LD    A,1                            ;get   current    state    of   interupts,    on/off,     into   P/V   flag
                         2208                       PUSH  AF                             ;and   save   for   later    so  can   turn  them   back   on   if  needed
                         2209  
                         2210                       LD    A,C                            ;Restore     controller     #
                         2211                       LD    BC,[STROBE_SET_PORT]           ;C<--SET     PORT   ,B<--RST     PORT
                         2212                       OUT   [C],A                          ;STROBE    10   SEGMENT     1 (SET)
                         2213                       LD    0,B                            ;SAVE   RESET    PORT
                         2214                       LD    HL,SPIN    SWO   CT            ;potnt   at   spinner     count    for  controller     O
                         2215                       LD    BC,[CONTROLLER_O_PORT]         ;C<--PORT    O,   B<--PORT    1
                         2216                       OR    A                              ;A contains      controtter      number
                         2217                       JR    NZ,GOT_CORRECT_CONTROLLER_IN_C ;
                         2218                       INC   HL                             ;Point    to  spinner     for  ctrir    1
                         2219                       LD    C,,B                           ;C<--PORT   1
                         2220  GOT_CORRECT_CONTROLLER_IN_C:                                      
                         2221                       XOR   A                              
                         2222                       LD    E,[HL]                         ;HAVE    SPIN   SWITCH    COUNT
                         2223                       LD    [HL],A                         ;>RESET    COUNT
                         2224                       LD    B,D                            ;>B<--RST    PORT
                         2225                       IN    A,[C]                          ;READ    DATA   FROM   SEG    1
                         2226                       CPL                                  
                         2227  ;
                         2228                       LD    H,O                            
                         2229                       LD    LA                             ;HL<--offset       into   DEC  _KBD_TBL
                         2230                       LD    A,C                            ;Swap    RST  PORT/DATA_    PORT
                         2231                       LD    C,8                            
                         2232                       OUT   [C],A                          ;STOBE    TO   SEG O    (reset)
                         2233                       LD    C,A                            ;C<--DATA      PORT
                         2234                       POP   AF                             ;get   back    entry   state    of   interupt    reg
                         2235                       JP    PO,LEAVE_THEM_OFF              
                         2236                       EI                                   ;turn    interrupts     back    on  only   if  they   were   on  entry
                         2237  LEAVE_THEM_OFF:                                           
                         2238                       LD    A,L                            
                         2239                       PUSH  AF                             ;save    raw   data   seg   !
                         2240                       AND   ARM_MASK                       ;Test    sleeve
                         2241                       LD    B,A                            ;>HAVE  ARM   DATA       (in  B)
                         2242                       LD    A,L                            
                         2243                       AND   KBD_MASK                       ;isolate     KBD   data
                         2244                       LD    L,A                            
                         2245                       PUSH  DE                             ;Save   spin    switch    count    on  stack   (reg   E)
                         2246                       LD    DE,DEC_KBD_TBL                 ;Get   top   of  keypad     decoder    table
                         2247                       ADD   HL,DE                          ;point    to  DEC  KBD_TBL      entry
                         2248                       POP   DE                             ;Restore     Spinner     count    (reg  EF)
                         2249                       LD    D,[HL]                         ;HAVE  KEYBOARD      DATA
                         2250                       IN    A,[C]                          ;segment     O  data
                         2251                       CPL                                  
                         2252  ;
                         2253                       PUSH  AF                             ;save   raw   data
                         2254                       LD    L,A                            
                         2255                       AND   FIRE  MASK                     ;isolate     fire   data
                         2256                       LD    H,A                            ;HAVE   FIRE  DATA
                         2257                       LD    A,L                            
                         2258                       AND   JOY MASK                       ;isolate     joystick     data
                         2259                       LD    L,A                            ;HAVE   JOY   DATA
                         2260                       POP   AF                             ;get   back   raw   data   for   seg   0
                         2261                       LD    C,A                            ;C  =  raw   data   segment     O
                         2262  
                         2263                       RET                                  
                         2264  
                         2265  ;
                         2266  ;  __POLLER
                         2267  ;
                         2268  ;   Used to fill a table of values for the 2 controllers
                         2269  ;   Does some debouncing if called twice in succession
                         2270  ;
                         2271  ;   NOTE   - Does not return at bottom of code, return is in middie
                         2272  ;            Interupts will be off for a while when call to DECODE is performed.
                         2273  ;
                         2274  ;   Callers   - This has different input parameters than OS-7 and
                         2275  ;               the controller map is ordered differently.
                         2276  ;
                         2277  ;
                         2278  ;Stack Usage:
                         2279  ;  will use 4 words   (2 pushes,  2  call)
                         2280  ;
                         2281  ;Calis:
                         2282  ;  __DECODER
                         2283  ;  DEBOUNCE
                         2284  ;  READ_N_DEBOUNCE      (a routine that is nested in _POLLER)
                         2285  ;
                         2286  ;Input  Parameters:
                         2287  ;  IX  - pointer to 1st byte of users controller map  (10  bytes)
                         2288  ;   A  - controller enabled and spinner enable
                         2289  ;          bit  O  - set if want controller O enabled
                         2290  ;          bit  1  - set if want controller 1 enabled
                         2291  ;          bit  7  - set if want spinner enabled for controllers which are  enabled
                         2292  ;
                         2293  ;Returns:
                         2294  ;
                         2295  ;  Data  in users   controller   map  is  like  this off  of  entry   IX value
                         2296  ;             IX+O   - joystick   O
                         2297  ;             IX+1   - fire  O
                         2298  ;             IX+2   - arm  O
                         2299  ;             IX+3   - keyboard   O
                         2300  ;             IX+4   - spinner   count  O
                         2301  ;             IX+5   - joystick   1
                         2302  ;             IX+6   - fire  1
                         2303  ;             IX+7   - arm  1
                         2304  ;             IX+8   - keyboard  1
                         2305  ;             IX+9   - spinner count  1
                         2306  ;
                         2307  ;   IX -  points to 1 byte past users data table of highest enabled controller
                         2308  ;
                         2309  ;
                         2310  ;   all  but  IY - destroyed
                         2311  ;
                         2312  ;Date:
                         2313  ;  9/24/83     11:14     JKL
                         2314  ;
                         2315  
                         2316  CONTROLLER_O_MASK    EQU   1H                             
                         2317  CONTROLLER_1_BIT     EQU   1                              
                         2318  SPINNER_ENABLE_BIT   EQU   7                              
                         2319  
                         2320  __POLLER:                                                 
                         2321                       LD    HL                             
                         2322                       LD    C,A                            
                         2323                       AND   CONTROLLER_0_MASK              
                         2324                       JR    Z,NOT_CONTROLLER_0             ;If not  then check   to see  if controller    1  is
                         2325                       DEC   A                              
                         2326                       CALL  READ_N_DEBOUNCE                
                         2327                       BIT   CONTROLLER_1_BIT,C             ;see ifcontroller   1 is active
                         2328                       RET   Z                              
                         2329  POLL_CONTROLLER_1:                                        ;getdata for controller    1
                         2330                       LD    A,01H                          
                         2331  READ_N_DEBOUNCE:                                          
                         2332                       PUSH  BC                             
                         2333                       PUSH  HL                             
                         2334                       CALL  __DECODER                      
                         2335                       LD    C,H                            
                         2336                       LD    A,L                            
                         2337                       POP   HL                             
                         2338                       CALL  DEBOUNCE                       
                         2339                       POP   BC                             
                         2340                       BIT   SPINNER                        
                         2341                       JR    2,NEXT_IX                      
                         2342                       LD    A,E                            
                         2343                       ADD   A,[IX+0]                       
                         2344                       LD    [IX+0],A                       
                         2345  NEXT_IX:             INC   IX                             
                         2346                       RET                                  
                         2347  
                         2348  
                         2349                       BIT   CONTROLLER_1_BIT,C             ;see if controller  1 itsenabled
                         2350                       RET   Z                              
                         2351                       LD    DE,0004H                       
                         2352                       ADD   HL,DE                          
                         2353                       INC   DE                             
                         2354                       ADD   IX,DE                          
                         2355                       JP    POLL_CONTROLLER   1            
                         2356  
                         2357  ;
                         2358  ;DEBOUNCE
                         2359  ;           This  wilL  check     for  equal  data on two passes,    and  if
                         2360  ;           the  data  its  the   same  then  the users buffer   is  updated.
                         2361  ;
                         2362  ;           This  is  done   by   check  for  equal data, if   the  data  is
                         2363  ;           different   on   each    call  then the data on   this  call  is
                         2364  ;           stored  so  that    the   next  call can use this   new  data.
                         2365  ;           If the  data    is  equa!   then  the data is stored    with  the
                         2366  ;           ni bit  (bit    7)  set   so that  the next calli  will  yield
                         2367  ;           different   data    (IE   there  could never be   a match  on  the
                         2368  ;           next  cal)).
                         2369  ;
                         2370  ;Stack   Usage:
                         2371  ;   1 word   (subroutine     cali)
                         2372  ;
                         2373  ;Input    Parameters:
                         2374  ;   HL  -  PoInter   to debounce      buffer
                         2375  ;   IX  -  Potnter   to users     controller   map
                         2376  ;   A   -  joystick   data
                         2377  ;   B   -  arm data
                         2378  ;   C   -  fire  data
                         2379  ;   D   -  keyboard   data
                         2380  ;
                         2381  ;Returns:
                         2382  ;   HL    - PoInting   to   next   buffer   (entry value +  4)
                         2383  ;   IX    - Pointing   to   next   data  area  (entry value   + 4)
                         2384  ;   A  is  changed
                         2385  ;   No  others   are  modified
                         2386  ;
                         2387  ;   Calls   self  as  a nested     subroutine   CHECK
                         2388  ;
                         2389  ;Date:
                         2390  ; 9/24/83       11:14       JKL
                         2391  ;
                         2392  ;
                         2393  DEBOUNCE:                                                 
                         2394                       CALL  CHECK                          ;debounce    joystick   data
                         2395                       LD    A,C                            ;debounce    fire  data
                         2396                       CALL  CHECK                          
                         2397                       LD    A,B                            ;debounce    arm  data
                         2398                       CALL  CHECK                          
                         2399                       LD    A,D                            ;debounce    keyboard   data
                         2400                                                            ;fall   thru  to  check   (return   imp!ied)
                         2401  CHECK                                                     
                         2402                       CP    [HL]                           ;see  if  data   was the   same  as  last   time
                         2403                       JR    NZ,NOT   SAME                  
                         2404  
                         2405                       OR    80H                            ;set  hi_order    bit  if  same,  so  not  equal    on   next   cal!
                         2406  NOT_SAME                                                  
                         2407                       LD    [HL],A                         ;update   local   debounce   buffer
                         2408                       INC   IX                             ;point   to  next  buffer   location
                         2409                       INC   HL                             ;        in  debounce   buffer   as  wel!
                         2410                       RET                                  
                         2411  
                         2412  ;
                         2413  ;Update_Spinner   - Controller spin switch interrupt  service routine
                         2414  ;
                         2415  ;  This routine  processes the spinner switch interrupt and updates
                         2416  ;    the data needed by both DECODER and POLLER
                         2417  ;
                         2418  ; Ram area used:  Updates SPIN_SW0_CNT and SPIN_SW1_CNT
                         2419  ;
                         2420  ; The spinner switch maskable interrupt is RST 38H
                         2421  ;
                         2422  ; Destroys AF, BC,  HL
                         2423  ;
                         2424  DIR_MASK             EQU   00100000B                      ;bit 5 tells us  the direction
                         2425  INTBIT               EQU   4                              ;bit that tells which   spinner   interrupted
                         2426  
                         2427  __UPDATE_SPINNER                                          
                         2428                       LD    BC,[CONTROLLER_0_PORT]         ;Get port values  for both  controllers
                         2429                       IN    A,[C]                          ;Input data from  controller   O
                         2430                       LD    HL,SPIN SWO_CT                 ;Poitntto spinner  update  data
                         2431                       BIT   INT_BIT,A                      ;Was this the controller   that   interrupted   ?
                         2432                       JR    NZ,GET_CONTROLLER_1            ;If not then check  controller    1
                         2433                       AND   DIR_MASK                       ;Check direction  bit
                         2434                       JR    NZ,INCREMENT_0_OIRECTION       ;If set then tncrement   direction
                         2435                       DEC   [HL]                           ;Else decrement direction
                         2436                       DEC   [HL]                           ;Decrement once more  to  fall  through   tncrement
                         2437  
                         2438  INCREMENT_0          DIRECTION:                                
                         2439                       INC   [HL]                           ;Increment direction
                         2440  
                         2441  GET_CONTROLLER_1                                          
                         2442                       LD    C,B                            ;Get controller  1 port  into  C
                         2443                       IN    A,[C]                          ;Get controller  1 data
                         2444                       INC   HL                             ;Point HL to controller   1 update   area
                         2445                       BIT   INT_BIT,A                      ;Is thIs the controller   that  interrupted    me?
                         2446                       RET   NZ                             ;Return if not, Also  don’t   assume
                         2447                                                            ; either controller  if  no bit  is  set
                         2448                       AND   DIR_MASK                       ;Check direction  bit
                         2449                       JR    NZ,INCREMENT_1_DIRECTION       ;I1fset then go  increment  direction
                         2450                       DEC   [HL]                           ;Else decrement direction
                         2451                       RET                                  ;Then return
                         2452  
                         2453  INCREMENT_1_DIRECTION                                      
                         2454                       INC   [HL]                           ;Increment direction
                         2455                       RET                                  ;Exit
                         2456  
                         2457  
                         2458  
                         2459  ;SESS   H SESS HEH HEHEHE HHS HEHEHE  HEHEHE  HEHE EEE EHH  HEHEHE   HEHEHE  EEESESEEHHEEEEE      HE HES
                         2460  
                         2461  ;                             NOTES TO SOUND PROGRAMMERS
                         2462  
                         2463  ;     The only differences between the OS7 version and this ADAM version
                         2464  ;     are transparent to the game programmer and important to the
                         2465  ;     sound programmer. Formerly CALL’s to PLAY_SONGS and SND_MANAGER
                         2466  ;     were necessary to update the sounds. Now a CALL to SOUNDS runs
                         2467  ;     the same code.   Formerly CALL’s to LEAVE_EFFECT and EFXOVER were
                         2468  ;     needed to end a SPECIAL EFFECT.  Now EFFECT_OVER runs the same code.
                         2469  ;     Independent CALL’s to PLAY_SONGS, SNO  MANAGER, LEAVE_EFFECT and
                         2470  ;     EFXOVER do not run in this module as before!!!!!
                         2471  
                         2472  ; PAC  OOO  EEE   OOOO  EERE   SEE   EEEEERESESEDERESSEREHEREESSEOREFEEEE             ORES    EEE EEERS
                         2473  
                         2474  ;          Operating     system     sound   routine    EQUATES
                         2475  
                         2476  OFF                  EQU   0FH                            ;Off,  no   sound
                         2477  
                         2478  ;          Special    byte   O  codes
                         2479  
                         2480  INACTIVE             EQU   0FFH                           
                         2481  ;@@e@  SEFFECT               EQU               62
                         2482  ENDSDATA             EQU   0                              
                         2483  
                         2484  ;          Offsets    within    an   SxDATA    song  data    area
                         2485  
                         2486  ;@ee@  CH                    EQU               Oo
                         2487  ;@e@   SONGNO                EQU               O
                         2488  ;@@@   NEXTNOTEPTR           EQU               1
                         2489  FREQ                 EQU   3                              
                         2490  ATN                  EQU   4                              
                         2491  CTRL                 EQU   4                              
                         2492  NLEN                 EQU   5                              
                         2493  ;@e@e  FPS                   EQU               6
                         2494  FPSV                 EQU   6                              
                         2495  FSTEP                EQU   7                              
                         2496  ;Oe     ALEN                 EQU               8
                         2497  ASTEP                EQU   8                              
                         2498  ;@@e@  APS                   EQU               9
                         2499  APSV                 EQU   9                              
                         2500  
                         2501  ;          song   end  codes
                         2502  
                         2503  ;@ee@  CHOEND                EQU               00010000B
                         2504  ;@ee@  CHIEND                EQU               01010000B
                         2505  ;@e@@  CH2END                EQU               10010000B
                         2506  ;@e@e@ CH3END                EQU               11010000B
                         2507  ;@@@   CHOREP                EQU               00011000B
                         2508  ;@e@e@ CHIREP                EQU               01011000B
                         2509  ;@@@   CH2REP                EQU               10011000B
                         2510  ;@@e@  CH3REP                EQU               11011000B
                         2511  
                         2512  ;          channel    numbers,     87   -B6
                         2513  
                         2514  ;@e@e@ CHO                   EQU               O
                         2515  ;@eeCH1             EQU        01000000B
                         2516  ;@eeCH2             EQU        10000000B
                         2517  ;ee@CH3             EQU        11000000B
                         2518  
                         2519  
                         2520  
                         2521  ;,SSeS S SHE SESE  HEHEHE  SHES  EH HERS
                         2522  ;-2          FREQ  SWEEP                 *
                         2523  ;,SSSSS  SSH   SEHHEHEHE   KES  EHHEHEED
                         2524  
                         2525  ;-See  Users’    Manual      for  description
                         2526  ;-RETs   2 SET:    {f   note   over
                         2527  ;-RETs   2 RESET:      if  sweep    in  progress     or  note    not  over
                         2528  
                         2529  FREQ_SWEEP                                                
                         2530  
                         2531  ;         *   if  freq    not   swept,    dec   NLEN   and   RET   [setting     Z  flag]
                         2532  
                         2533                       LD    A,[IX+FSTEP]                   ;check     for   no  sweep    code
                         2534                       OR    A                              ;SET   Z  flag   if  FSTEP    =  O
                         2535                       JR    NZ,L20                         ;if  PSW   is  zero   note    not   to   be  swept
                         2536                       LD    A,[IX+NLEN]                    ;dec   NLEN   and
                         2537                       DEC   A                              ;SET   Z flag    if  NLEN   =  O
                         2538                       RET   Z                              ;leave    if  note   over   with    Z  flag     SET
                         2539                       LD    [IX+NLEN],A                    ;store   decremented       NLEN
                         2540                       RET                                  ;RET   with   Z  flag   RESET    [note    not    over]
                         2541  
                         2542                       ENDIF                                
                         2543  
                         2544  ;          ¢  sweep     going.    so   dec   FPSV
                         2545  
                         2546  L20                                                       
                         2547                       PUSH  IX                             ;point   HL   to  FPSV
                         2548                       POP   HL                             
                         2549                       LD    DE,FPSV                        
                         2550                       ADD   HT,DE                          
                         2551                       CALL  LOCL_DECLSN                    ;dec   FPSV
                         2552  ;ees %    JR           NZ,L21                  -if  PSW   is  zero   FPSV   has    timed    out
                         2553                       RET   NZ                             ;Added   u0S
                         2554  
                         2555  ;             *  dec    NLEN   and   leave    if  sweep    is  over
                         2556  
                         2557                       CALL  LOCL_MSNTOLSN                  ;reload    FPSV   from   FPS
                         2558                       DEC   HL                             ;point    to   NLEN   [#  steps    in   the   sweep]
                         2559                       LD    A,[HL]                         ;dec   NLEN    and
                         2560                       DEC   A                              ;SET    Z flag    {tf NLEN   =  O
                         2561                       RET   2                              ;leave   if   sweep   over   with    Z   flag    SET
                         2562  
                         2563  ;               *  sweep     not  over,    so   add   FSTEP   to  FREQ
                         2564  
                         2565                       LD    [HL],A                         ;store    decremented      NLEN
                         2566                       DEC   HL                             ;poitnt   HL
                         2567                       DEC   HL                             ;to   FREQ
                         2568                       LD    A,[IX+FSTEP]                   ;A   = FSTEP    [two’s    complement       step    size]
                         2569                       CALL  LOC_ADD816                     ;FREQ    = FREQ    + FSTEP
                         2570                       INC   HL                             ;point    HL   to  hi  FREQ
                         2571                       RES   2,[HL]                         ;RESET    82   itn hi  FREQ    in  case    add    caused    >  10  bit   FREQ
                         2572                       OR    OFFH                           ;RESET    Z  flag,    sweep   not    over    yet
                         2573  
                         2574                       ENOIF                                
                         2575  ;@@@  121
                         2576                       RET                                  
                         2577  ;       ENO FREQSWE
                         2578  
                         2579  
                         2580  ;, eet  eeeeereeeeeeeeeeeeeeseres
                         2581  ;*            ATN_SWEEP                  *
                         2582  ; ee   eeeresereeeeeeereeesesers
                         2583  
                         2584  ;See   User's     Manual!   for  description
                         2585  ;RETs     Z  SET:    tf byte    8  is  O  [means     sweep     is  over,    or   note    was    never   swept]
                         2586  ;RETs     Z  RESET:     if sweep    in  progress
                         2587  
                         2588  ATN_SWEEP                                                 
                         2589  
                         2590  ;            *  RET   with   Z  SET   if  byte    8  =  00
                         2591  
                         2592                       LD    A,[1X+8]                       ;check    byte    8  for   no   sweep     code
                         2593                       OR    A                              ;Z2  1s  set   if   byte   8   = O
                         2594                       RET   2                              ;leave     if  Z  set,    sweep    not    going
                         2595  
                         2596  ;            *  sweep   going,    so   dec   APSV
                         2597  
                         2598                       PUSH  IX                             ;point    HL   to   APSV
                         2599                       POP   HL                             
                         2600                       LD    DE,APSV                        
                         2601                       ADD   HL,DE                          
                         2602                       CALL  LOCL  DECLSN                   ;dec   APSV     [LSN   of   byte    9]
                         2603  ;*eee8        JR         NZ,L22                   ;1f  PSW    ts  zero    APSV    has   timed     out
                         2604                       RET   NZ                             ;Added    u0S
                         2605  
                         2606  ;            *  dec   ALEN   to  see   if  sweep     over
                         2607  
                         2608                       CALL  LOCL  MSNTOLSN                 ;reload      APSV   from    APS
                         2609                       DEC   HL                             ;point     to  ALEN     [4  of   steps     in   the  sweep]
                         2610                       CALL  LOCL_DECLSN                    ;dec   ALEN     [LSN   byte    8]
                         2611                       JR    Z,L23                          ; if  PSW    is  non-zero      sweep    not    over    yet
                         2612  
                         2613  ;            *  add   ASTEP   to  ATIN
                         2614  
                         2615                       LD    A,[HL]                         ;>MSN   A  =  ASTEP
                         2616                       AND   OF OH                          ;mask    USN
                         2617                       LD    E,A                            ;E   =  ASTEP       O
                         2618                       DEC   HL                             ;point     HL  to   ATN
                         2619                       DEC   HL                             
                         2620                       DEC   HL                             
                         2621                       DEC   HL                             
                         2622                       LD    A,[HL]                         ;>MSN   A  =  ATN
                         2623                       AND   OF OH                          ;A   =  ATN      Oo
                         2624                       ADD   A,E                            ;MSN    A  =  [ASTEP     +  ATN]       Oo
                         2625                       LD    E,A                            ;E   =  [ASTEP    +   ATN]       O
                         2626                       LD    A,[HL]                         ;A   =  ATTN.    freq    or   CTRL
                         2627                       AND   OFH                            ;smask   old   ATN      A  =0      freq     or   CTRL
                         2628                       OR    E                              ;OR   in   new   ATN
                         2629                       LD    [HL],A                         ;store     updated      value   back     into    song   data    area
                         2630                       OR    OF FH                          ;RESET     Z  flag.     sweep    not  over     yet
                         2631  ;*ee08        JR         L22
                         2632                       RET                                  ;Added     uO0S
                         2633  
                         2634  ;            ELSE       Z2 flag   is  SET:     sweep    over
                         2635  
                         2636  L23                                                       
                         2637                       LD    [HL],0                         ;set byte 8  to  O to indicate  end  sweep
                         2638  
                         2639  ;       ENDIF
                         2640  ;       ENDIF
                         2641  
                         2642  ;@ee@122
                         2643                       RET                                  
                         2644  
                         2645  ;       END ATNSWEE
                         2646  
                         2647  
                         2648  
                         2649  ;seSSSSS SSS SHH HEHESSEHTSEHHHEEEES
                         2650  ;°8        UPATNCTRL                +
                         2651  ; SSSSSHSHEHESSS  EES       EHEE EES
                         2652  
                         2653  ;Perform  single    byte  update    of  the   snd  chip  notse   contro!    register      or  any
                         2654  ;attenuation    register.    IX  is  passed    pointing    to byte    O of  a  song   data    area,    MSN
                         2655  ;register   C  = formatted    channel    attenuation     code.
                         2656  
                         2657  UPATNCTRL                                                 
                         2658                       LD    A,[1X+4]                       ;MSN   A  = ATN,   LSN  may   be  CTRL   data
                         2659                       BIT   4,C                            ;test   for   AITN
                         2660                                                            ;>{f   PSW  is  non-zero    ATN   is  to  be  sent,
                         2661                                                            ; move    it  to  the  LSN
                         2662                       JR    Z,L24                          
                         2663                       RRCA                                 ;Swap   nibbles
                         2664                       RRCA                                 
                         2665                       RRCA                                 
                         2666                       RRCA                                 ;°>LSN  A  = ATN
                         2667  
                         2668  ;        ENDIF
                         2669  
                         2670  L24                                                       
                         2671                       AND   OFH                            ;mask   MSN
                         2672                       OR    C                              ;4   = formatted    registers       ATN   or  CTRL
                         2673  ;sees     CALL       OUT_TO_SOUNO   PORT       ;Output   ATN  or  CTRL   data
                         2674  ;Seeses   RET
                         2675                       JP    QUT _TO_SOUND   PORT           ;output   ATN  or  CTRL   data
                         2676  
                         2677  
                         2678  
                         2679  ;,F8teseseseeeeereseeeeeeeeese
                         2680  ;*          UPFREQ                    *
                         2681  ;,Ses  eeeereseeeeeeereeeresesese
                         2682  
                         2683  ;Perform    double    byte   update     of  a sound   chip    frequency      register.       IX   its passed
                         2684  ;pointing     to  byteO   of   a  song   data  area,   MSN    register     D  =  formatted      channel!
                         2685  ;frequency     code.
                         2686  
                         2687  UPFREQ                                                    
                         2688                       LD    A,[IX+FREQ]                    ;A =  F2  F3   F4  FS   F6   F7  FB  FIO
                         2689                       AND   OFH                    7A =   0   O     O   O  F6   F7  FB  FQ 
                         2690                       OR    D                              ;A =   formatted      reg/#      F6  F7   FB  FO
                         2691                       CALL  OUT_TO_  SOUND    PORT     =   ;output   first    freq   byte
                         2692                       LD    A,[IX+FREQ]                    ;A =  F2  F3   F4  FS  F6    F7  F8  FO   again
                         2693                       AND   OFOH                   :A =  F2  F3   F4  F5    0    0   0    O 
                         2694                       LD    DA                             ;save  in  D
                         2695                       LD    A,[IX+FREQ+1]                  ;LSN  A  =O     O  FO  Fi
                         2696                       AND   OFH                    “A=    0   0    0   0    0    OFO    FI! 
                         2697                       OR    D                              ;A =  F2  F3   F4  FS    O    O  FOF!
                         2698                       RRCA                                 ;Swap  nibbles
                         2699                       RRCA                                 
                         2700                       RRCA                                 
                         2701                       RRCA                                 ;A =   O   O   FO  F1  F2   F3   F4  F5
                         2702  ;*e%%       CALL       OUT_TO_SOUND     PORT     ;output     2nd   [most    significant]       freq    byte
                         2703  ;eee        RET
                         2704                       JP    OUT_TO_SOUND_PORT              ;output     2nd   [most    significant]       freq    byte
                         2705  
                         2706  
                         2707  
                         2708  ;eSSSESHHHSSSESEEHHESESHSEES
                         2709  ;¢       LOCL_DECLSN       *
                         2710  ;SSSSSHESSHSSSHESSSHHHSHEEOS
                         2711  
                         2712  ;Without affecting the MSN, decrement  the LSN of  the  byte   pointed to by   HL.
                         2713  ;HL remains the same.
                         2714  ;RET with Z flag set if dec LSN results  in O, reset   otherwise.
                         2715  ;RET with C flag set if dec LSN results  in -f,  reset  otherwise.
                         2716  
                         2717  __DECLSN:                                                 
                         2718  LOCL_DECLSN                                               
                         2719                       XOR   A                              
                         2720                       RRD                                  ;& = 0    LSN [HL]
                         2721                       SUB   1               :2 FLAG  SET [TF DEC  TO O,C  FLAG IF DEC   TO  -!1 
                         2722                       PUSH  AF                             ;save  Z and C flags
                         2723                       RLD                                  ;[Ht}) = old MSN    new  LSN
                         2724                       POP   AF                             ;restore  Z and  C flags.   A    O   new LSN
                         2725                       RET                                  
                         2726  
                         2727  
                         2728  
                         2729  ;eeeeeeeseeeesetesreoeseseresese
                         2730  ;*       LOCL_DECMSN       *
                         2731  ;eeeeeeseseaseesesrereeresee
                         2732  
                         2733  ;Without affecting the LSN, decrement the MSN of the byte potnted to by HL.
                         2734  ;HL remains the same.
                         2735  ;RET with Z flag set if dec MSN results in O, reset otherwise.
                         2736  ;RET with C flag set if dec MSN results im -1, reset otherwise.
                         2737  
                         2738  DECMSN                                                    
                         2739  LOCLDECMSN                                                
                         2740                       XOR   A                              
                         2741                       RLD                                  ;A = O   MSN [HL]
                         2742                       SUB   1                              ;2 flag set if dec to O, C flag set if dec  -i
                         2743                       PUSH  AF                             ;save Z and C flags
                         2744                       RRD                                  ;{HtL)= new MSN   old LSN
                         2745                       POP   AF                             ;srestoreZ and C flags, A =0    new MSN
                         2746                       RET                                  
                         2747  
                         2748  
                         2749  
                         2750  ;,tHeeeeeseceseseeeesereeress
                         2751  ;*       LOCL_MSNTOLSN     :
                         2752  
                         2753  
                         2754  ;Copy MSN of the byte pointed to by HL to tne iSN of that byte      Hi  remains
                         2755  ;the same.
                         2756  
                         2757  MSNTOLSN                                                  
                         2758  LOCi_MSNTOLSN                                             
                         2759                       LD    AA[HT]                         ;A = MSN   LSN to be changed
                         2760                       AND   OFOH            >A = MSN   0   
                         2761                       LD    8A                             ;save in B
                         2762                       RRCA                                 ;Swap nibbles
                         2763                       RRCA                                 
                         2764                       RRCA                                 
                         2765                       RRCA  7A = 0   MSN                   
                         2766                       OR    8                              ;& = MSN   MSN
                         2767                       LD    [HIL],AA                       ;(HtL]= MSN   MSN
                         2768                       RET                                  
                         2769  
                         2770  
                         2771  
                         2772  ;5SSSSeSHEHESSSHEHHEHEHEHHEEE
                         2773  ;*       LOC_aDD816        e
                         2774  ; SSS     SSSHSHEHEEHEEEEE HE
                         2775  
                         2776  ;Adds 8 bit two’s complement signed vaiue passed in A to the 16 bit    location
                         2777  ;pointed to by HL.
                         2778  
                         2779  ADDB16                                                    
                         2780  LOC_ADDB16                                                
                         2781                       LD    B,0                            ;set B for positive value inA
                         2782                       BIT   7,A                            ;1f A is positive
                         2783                       JR    Z,POS                          ;skip
                         2784  ;eee8    LD  b,0FFh                    7A 16 neg: extend sign bit thru 8
                         2785                       DEC   B                              ;Added u0S
                         2786  POS                                                       
                         2787                       ADD   A,[HL]                         ;do 8 bit add [and set Carry]
                         2788                       LD    [HL],A                         ;store result into LSB 16 bit number
                         2789                       INC   HL                             ;put SB
                         2790                       LD    A,[HL]                         ;into A
                         2791                       ADC   A,B                            ;A = MSB + Carry + B [8B{tsO or FF)
                         2792                       LD    [HL],A                         ;store result into MSB
                         2793                       DEC   HL                             ;re-point HL to LSB 16 bit number
                         2794                       RET                                  
                         2795  
                         2796  
                         2797  
                         2798  ; eeeeeeveseereseereseresretes
                         2799  ;*     PT_IX_TO_SxDATA     +
                         2800  ;,Seeeeeeeeseraeeeeseseeeresers
                         2801  
                         2802  ;SONGNO passed in 8.       
                         2803  ;Potnt IX to byte O tn SONGNO‘s song data area.
                         2804  ;:RETwith both DE and IX potnting to SxDATA,
                         2805  ;HL pointing to MSB SxDATA entry itnLST_OFSND ADORS.
                         2806  
                         2807  PT_IX_TO_SxDATA                                           
                         2808  
                         2809  ;       * IX & DE := addr of byte O itnSONGNO’s song  data  area,
                         2810  ;       HL pointing to MSB SxDATA entry in LST_OFSND_ADDRS.
                         2811  
                         2812                       LD    HL,[PTR_TO_LST_OF_SNOD_ADDRS]  ;poftntHL to  start  LST_OF_SNO_ADORS
                         2813                       DEC   HL                             ;init HL for addition
                         2814                       DEC   HI                             
                         2815                       LD    C,,8            :FORM 4 ¢ SONGNO IN C 
                         2816                       LD    B,O                            
                         2817                       RLC   C                              
                         2818                       RLC   C                              
                         2819                       ADD   HL,BC           :HL PTS TO SXDATA’S ENTRY  IN LST_OF SND ADORS 
                         2820                       LD    E,[HT]                         ;move addr SxDATA to IX thru  DE
                         2821                       INC   HL                             
                         2822                       LD    D,[HT]                         
                         2823                       PUSH  DE                             
                         2824                       POP   IX                             
                         2825                       RET                                  
                         2826  
                         2827  
                         2828  
                         2829  ;,seeteeeeasereseereeresesece
                         2830  ;*      AREA SONG   _IS         «
                         2831  ; eeeeeeeeeseeseeeereseseresce
                         2832  
                         2833  ;The address   of  byte  0  of a song  data   area   is passed    in  IX.   The  song  number  of
                         2834  ;the song  using   that  area  is returned    in  A  [OFFH   {f  inactive].     If a  special
                         2835  ;effect was  using   that   area, 62   is returned    in  A  and  HL  {ts returned   with the
                         2836  ;address of  the   special   sound  effect  routine.
                         2837  
                         2838  AREA_SONG_IS                                              
                         2839                       LD    A,[1IX+0]          7A  := CHA      SONGNO   OR  62,OR  A  := FF 
                         2840                       CP    OFFH                           
                         2841                       RET   2                              ;leave   with   A =  FF  if  area   inactive
                         2842                       AND   00111111B          SMASK  CHA  
                         2843                       CP    62                             
                         2844                       RET   NZ                             ;leave   with  A  =  SONGNO   if  not  a  special  effect   [62]
                         2845  
                         2846  ;       special   effect,    so set  Hl to  addr   effect,    stored  in   bytes  1&2
                         2847  
                         2848                       PUSH  IX                             ;point   HL  to  byte   1
                         2849                       POP   HL                             
                         2850                       INC   HL                             
                         2851                       LD    E,[HL]                         ;save  LSB   effect   addr   ine
                         2852                       INC   HL                             ;HL  to  byte  2
                         2853                       LD    D,[HL]                         ;save  MSB   effect   addr   inoO
                         2854                       EX    DE,HL                          ;HL  :=  addr  special    effect
                         2855                       RET                                  
                         2856  
                         2857  ;       END  UTIL
                         2858  
                         2859  
                         2860  
                         2861  ;****************************
                         2862  ;*       INIT_SOUND         *
                         2863  ;****************************
                         2864  
                         2865  ;See Users’ Manuai for description;   includes ENTRY_POINT_ALL_OFF
                         2866  ;addr LST_OF_SND_ADDRS passed in HL
                         2867  ;n = # of song data areas to init, passed in B
                         2868  
                         2869  ;       *** Sound chip register   code EQUATES ***
                         2870  
                         2871  ;       Tone generator frequency   and attenuation formatted register   codes
                         2872  
                         2873  SRIFRQ               EQU   10000000B                      ;BIT7 = 1, BIT6-4 = TONE GEN 1 FREQ  CODE
                         2874  SRIATN               EQU   10010000B                      ;BIT7 = 1, BIT6-4 = TONE GEN 1 ATTN  CODE
                         2875  SR2FROQ              EQU   10100000B                      ;BIT7 = 1, BIT6-4 = TONE GEN 2 FREQ  CODE
                         2876  SR2ATN               EQU   10110000B                      ;BIT7 = 1, BIT6-4 = TONE GEN 2 ATTN  CODE
                         2877  SR3FRQ               EQU   11000000B                      ;BIT7 = 1, BIT6-4 = TONE GEN 3 FREQ  CODE
                         2878  SR3AIN               EQU   11010000B                      ;BIT7 = 1, BIT6-4 = TONE GEN 1 ATTN  CODE
                         2879  
                         2880  ;       Noise generator control and attenuation formatted register codes
                         2881                       .                                    
                         2882  SRNCTL               EQU   111000008                      ;BIT7 = 1, BIT6-4 = NOISE GEN  CONTROL  CODE
                         2883  SRNATN               EQU   111100008                      ;BIT7 = 1, BIT6-4 = NOISE GEN  ATTN  CODE
                         2884  
                         2885  
                         2886  ;eee INITSOUND
                         2887  
                         2888  ;    :  ¢ inittalize PTR_TO_LST_OF  SND _ADORS with value passed  in  HL
                         2889  
                         2890                       LD    [PTR_TO_LST_OF_SND_ADDRS],HL   
                         2891  
                         2892  ;       * store inactive code   at byte O of each of the n data  areas  [B  = n)
                         2893  
                         2894                       INC   HL                             ;pt HL to song 1 data area entry   in LST_OF_SND_ADDRS
                         2895                       INC   HL,                            
                         2896                       LD    —,[HL]                         ;pt DE to byte 0 in first song  data  area
                         2897                       INC   HL                             
                         2898                       LD    0D[HL]                         
                         2899                       EX    DEHL                           ;pt HL to byte O in first song  data  area
                         2900                       LD    DE,10                          ;set DE for 10 byte increment
                         2901                       LD    A,OFFH                         ;Added u0S
                         2902  B1:                                                       
                         2903                       LD    [HL],A                         ;Geactivate area  *** Added u0S
                         2904                       ADD   HL,DE                          ;pt HL to byte O next area (10  bytes  away)
                         2905                       DJNZ  B1                             ;do this for the n (passed in B)  data  areas
                         2906  
                         2907  ;       *¢store end of data  area  code (0) at first byte after  last  song  data  area
                         2908  
                         2909                       LD    [HL],0                         ;store end of data area code  in byte  O data   area  n+   1
                         2910  
                         2911  ;       * set the 4 channel! data  area pointers to a dummy, inactive   data  area
                         2912  
                         2913                       LD    HL,DUMAREA                     ;point HL to inactive byte below  [after   the  RET]
                         2914                       LD    [PTR TOS ON _O],HL             ;store addr DUMAREA at PTR_TOS  ON  _O
                         2915                       LD    [PTR_TO_SON _1],HL             ;store addr DUMAREA at PTR_TO_S ON 1
                         2916                       LD    [PTR_TO_SON 2],HL              ;store addr f  ‘REA at PTR_TO_S ON  2
                         2917                       LD    [PTR_TO_SON_3],HL              ;store addr  DUMAREA at PTR TO SON  3
                         2918  
                         2919  ;       *  initializeSAVECTRL
                         2920  
                         2921  ;eeses   LD      A,OFFH          ;note: this  ts only time MSN SAVE CTRL  will be non zero,
                         2922  ;*see¢                           ;Out uOS (loaded  earlier)
                         2923  
                         2924                       LD    [SAVE CTRL],A                  ;thus ensuring  PLAYSONGS  will output  ist real CTRL data
                         2925  __TURN_OFF_SOUND:                                         
                         2926  ;@e@eALLOFF
                         2927  
                         2928  ;       * turn off all 4 sound generators
                         2929  
                         2930                       LD    A,[SOUNODPOR]                  ;Added u0S
                         2931                       LD    C,A                            ;Added u0S
                         2932                       LD    A,OFF+SRIATN                   ;form off code  for tone generator  1
                         2933                       OUT   [C],A                          ;send {ftout
                         2934                       LD    A,OFF+SR2ATN                   ;form off code  for tone generator  2
                         2935                       OUT   [C],A                          ;send it out
                         2936                       LD    A,OFF+SR3ATN                   ;form off code  for tone generator  3
                         2937                       OUT   [C],A                          ;s8endit out
                         2938                       LD    A,OFF+SRNATN    :FORM OFF CODE  FOR NOISE GENERATOR,N 
                         2939                       OUT   [C],A                          ;send it out
                         2940                       RET                                  
                         2941  
                         2942  DUMAREA              DEFB  INACTIVE                       
                         2943  
                         2944  ;       END INITSOU
                         2945                                                            ;
                         2946  
                         2947  
                         2948  eeeeeeeeeeeresereseeeeereees                                      
                         2949  ;*        JUKE  _BOX               ‘
                         2950  ,EEE                 eeereeesreeeseeereeereees                                
                         2951  
                         2952  ;see  Users’  Manual!   for  description
                         2953  ;SONGNO  passed  in   B
                         2954  
                         2955  PLAY                 _IT                                  
                         2956  JUKE                 BOX                                  
                         2957  
                         2958  ;        * RET   if  song   already    in progress
                         2959  
                         2960                       PUSH  BC                             ;save  SONGNO  on  stack
                         2961                       CALL  PT_IX_TO_SXDATA                ;point   IX to SONGNO’s   song  data  area
                         2962                       LD    A,[1XX+0]                      ;A  := CH#  [if any]     SONGNO   [if any]
                         2963                       AND   3FH                  >A  := 0 O SONGNO 
                         2964                       POP   BC                             ;B  := SONGNO
                         2965                       CP    8                              ;test   ifalready    in progress
                         2966                       RET   2                 '   IF   SO,LEAVE 
                         2967  
                         2968  ;        *  load  first   note   and  set  NEXT_NOTE  PTR   [thru  LOAD  NEXT_NOTE]
                         2969  
                         2970                       LD    [1X+0],B                       ;store  SONGNO  in  byte  O
                         2971                       DEC   HL                    >-HL  LEFT BY  PT_IX_TO_SXDATA     POINTING   TO  MSB  SXDATA 
                         2972                       DEC   HL                             ;-entry   in LST_OF_SNO_ADDRS     point  Ht  to  note  list
                         2973                       LD    D,[HT]                         ;"Starting  addr  entry   in  LST_OF_SND_ADDRS     and  save   this
                         2974                       DEC   HL                             ;-addr  in DE
                         2975                       LD    E,[HL]                         ;DE  now has  the  initial   value  for  NEXT _NOTE_PTR
                         2976                       LD    [IX+1],€                       ;set  NEXT_NOTE PTR   for  first   note  in  song
                         2977                       LD    [I1X+2],D0                     
                         2978                       CALL  LOAD  _NEXT_NOTE               ;load  note,  byte  0 :=  CH#  SONGNO,   set  new  NEXT NOTE  PTR
                         2979                       JR    UP_CH_DATA_PTRS                ;new  song, so  update   channel!  data  ptrs
                         2980                                                            ;
                         2981  ;        END  JUKEBOX
                         2982  
                         2983  
                         2984  
                         2985  ;FSSeeeeeeee eee eeaeeee eeeeese
                         2986  ;*      PLAY SONGS  _          *
                         2987  ;,Seeeeeseseseseeseeeeseseeeseeeens
                         2988  
                         2989  ;       **¢  Sound  chip  register   code  EQUATES
                         2990  
                         2991  ;@@@ WHITE        EQU        00000 1008     ;BIT2  =  1, white  noise   code
                         2992  ;@@e@PERIOD       EQU        000000008      ;BIT2  = O,  periodic   noise   code
                         2993  ;@@e@NSRHI        EQU        000000008      :B:TO-1  Set  for  highest   noise    shift   rate   {N/512]
                         2994  ;ee@@NSRMED       EQU        0000000  18    ;BITO-1  Set  for  medium   noise   shift    rate   [N/1024]
                         2995  ;ee@ NSRLOW       EQU        000000  108    ;BITO-1  Set  for   lowest  noise   shift    rate   [N/2048]
                         2996  ;ee@ NSRTG3       EQU        000000  11B    :BITO-1  Set  for  shift   from   tone  gen   3  output
                         2997  
                         2998  SOUNDS                                                    
                         2999  ;@e@@PLAYSONGS   _
                         3000  
                         3001  ;       * output   CH! attenuation     and frequency
                         3002  
                         3003                       LD    A,OFFTSRIATN                   ;format  CH!  OFF  byte   into A
                         3004                       LD    ,C,SR1IATN                     ;format  MSN  C  for  CH1iattenuation
                         3005                       LD    D,SRIFRO                       ;format  MSN  O  for  CHi frequency
                         3006                       LD    IX,[PTR_TO_S   ON  _1]         ;point   IX  to byte  O  data  area   of  song   for  CH!
                         3007                       CALL  TONEOUT                        
                         3008  
                         3009  ;       * output   CH2 attenuation     and frequency
                         3010  
                         3011                       LD    A,OFF+SR2ATN                   ;format  CH2  OFF  byte   into A
                         3012                       LD    C,SR2ATN            :FORMAT  MSN  C  FOR CH2,ATTENUATION 
                         3013                       LD    D,SR2FRO                       ;format  MSN  D  for CH2  frequency
                         3014                       LD    IX,[PTR_TO_S   ON 2]           ;point  IX  to  byte  O  data  area   of  song   for  CH2
                         3015                       CALL  TONE_OUT                       
                         3016  
                         3017  ;       * output   CH3 attenuation     and frequency
                         3018  
                         3019                       LD    A,OFF+¢SR3ATN                  ;format  CH3  OFF  byte  into  A
                         3020                       LD    C,SR3ATN            >FORMAT  MSN  C  FOR CH3  ATTENUATION 
                         3021                       LD    D,SR3FROQ           >FORMAT  MSN  D  FOR CH?  FREQUENCY 
                         3022                       LD    ,IX,[PTR_TO_S  ON  3]          ;potnt  IX  to  byte  O data   area   of  song   for  CH3
                         3023                       CALL  TONE_OUT                       
                         3024  
                         3025  ;       * output   CHO [noise]   ATN   [and CTRL,   if  different   from   last   time]
                         3026                       .                                    
                         3027                       LD    A,OFF+SRNATN                   ;>format CHO  OFF  byte  into  A
                         3028                       LD    C,SRNATN                       ;format  MSN  C for  CHO  attenuation
                         3029                       LD    IX,[PTR_TO_S_  ON _O]          ;point  IX  to  byte  O data   area   of  song   for  CHO
                         3030                       LD    E,[1X+0]                       ;look for  inactive    code,  OFFH
                         3031                       INC   3=€                            ;this  sets  Z  flag   if E  = OFFH
                         3032                       JR    NZ,LS                          ;{f PSW  1s zero   song  data  area  is   inactive
                         3033                       CALL  OUTTO  SOUND   PORT            ;turn  off  CHO
                         3034                       JR    L6                             ; SND_MANAGER
                         3035  
                         3036  ;       ELSE
                         3037  
                         3038  L5                                                        
                         3039                       CALL  UPATNCTRL                      ;send  out  current   ATN
                         3040                       LD    &,EIUX4+CTRL]                  ;LSN  A  = current   CTRL  data
                         3041                       AND   OFH                            ;mask  MSN
                         3042                       LD    HL,SAVE CTRL                   ;point  to  last CTRL    data  sent
                         3043                       CP    [HT J                COMPARE   
                         3044                       JR    7,16             >IF PSW   IS ZERO  CTRL  HAS   NOT  CHANGED     [DONE] 
                         3045                       LD    [HLJ],A                        ;SAVE CTRL   = new  CTRL   data
                         3046                       LD    C,SRNCTL                       ;send  new CTRL  data
                         3047                       CALL  UPATNCTRL                      
                         3048                       JR    L6                   SNO_ MANAGER 
                         3049  
                         3050  ;         ENDIF
                         3051  ;         ENDIF
                         3052  
                         3053  TONE                 OUT                                  
                         3054                       LD    E,[1X+0]                       ;look   for  inactive  code,   OFFH
                         3055                       INC   E                              ;this  sets  Z  flag   if  E = OFFH
                         3056                       JR    NZ,L7                          ;if  PSW  is zero  song    data  area    is  inactive
                         3057  ;#448      CALL      OUT_TO_  SOUND PORT     =;turn off  CHx
                         3058  ;*ees      JR      ~—~6t8s
                         3059                       JP    OUT_TO_SOUND_PORT              ;turn  off  CHx
                         3060  
                         3061  ;         ELSE  send  out  current    ATN and  FREQ
                         3062  
                         3063  L7                   .                                    
                         3064                       CALL  UPATNCTRL           :SEND  OUT  ATTENUATION 
                         3065                       JP    UPFREQ                         ;send  out  frequency
                         3066  *EE8                 CALL  UPFREQ                         ;send  out  frequency
                         3067  L8                                                        
                         3068  SESS                 RET   -                              
                         3069  ;         ENDIF
                         3070  ;eeeeeeeeeeseseseeeeerereseese
                         3071  
                         3072  ;:¢      SNO_MANAGER         ‘
                         3073  
                         3074  
                         3075  ;See Users’ Manual  for description
                         3076  
                         3077  16                                                        
                         3078  SNO_MANAGER                                               
                         3079  
                         3080  ;       * IX  :* addr of song  #1  data  area  [SiDATA]
                         3081  
                         3082                       LD    B,1               :PT  IX  TO BYTE  O SONG   DATA  AREA  FOR  SONG 14 
                         3083                       CALL  PT_[X_TO_SXDATA                
                         3084  
                         3085  LI                                                        ;LOOP  until  end  of  song  data   areas
                         3086                       LD    A,ENOSDATA                     ;check  for  end  of  song  data  areas
                         3087                       CP    [1X+0]            :SET  Z FLAG  IF  INACTIVE 
                         3088                       RET   ZZ                :LEAVE   [Z SET],IF  ALL  DATA  AREAS   HAVE BEEN  PROCESSED 
                         3089  
                         3090  ;       * process  active song   data areas
                         3091  
                         3092                       CALL  PROCESSDATA_AREA               ;   update   counters   or call   effect  get  next  note
                         3093  
                         3094  ;       * point  IX to byte  O next  song  data  area
                         3095  
                         3096                       LD    DE,10                          
                         3097                       ADD   IX,DE                          
                         3098                       JR    LF                             ;REPEAT  LOOP
                         3099  
                         3100  
                         3101  
                         3102  ;Seeeeeaeeeeseeeeeeeeeseserss
                         3103  ;*     UP_CH DATA   _PTRS       -
                         3104  
                         3105  
                         3106  ;For each active   data  area,   starting    with   SIDATA  and  proceeding     in order,    toad
                         3107  ;the associated   channel!  data   area  pointer    [PTR_TO_S  ON x}   with   the  address    of
                         3108  ;byte O.This  routine    is called    by JUKE BOX,    when  a  song  starts   and
                         3109  ;PROCESSDATA_AREA     when  the  channel    using  a  data  area  has  changed    as  a  result   of
                         3110  ;calling LOAD_NEXT_NOTE     [this   happens   when   a song  finishes    and  when   it switches
                         3111  ;back and forth   between   noise   and   tone notes].
                         3112  
                         3113  UP_CHDATA            _PTRS                                
                         3114                       PUSH  IX                             ;Save  curent   IX
                         3115                       LD    HI,DUMAREA                     ;set  all  4 ch  data  ptrs   to dummy    inactive    area
                         3116                       LD    [PTR_TO_S  ON  _O],HL          
                         3117                       LD    [PTR_1O_  SON  1],HL           
                         3118                       LD    [PTR_TO_S  ON  2],HL           
                         3119                       LD    [PTR _TO_S ON  3],HL           
                         3120                       LD    A                              ;set  IX  to byte   O SIDATA
                         3121                       CALL  PTIX_TO_SXDATA                 ;RETS  with   IX addr  byte  O  song   1
                         3122  
                         3123  L2                                                        ;LOOP  until   end  of song  data   areas
                         3124                       LD    A,[1IX+0]                      ;test  for  end  of  song  data  araes
                         3125                       OR    A                              ; #00   CP        ENDSDATA
                         3126                       JR    Z,O00NE_SNOMAN                 ;leave  loop   if all  data  areas   checked
                         3127  
                         3128  ;       *  {f area  active,   set   appropriate    channel!  data  area   pointer
                         3129  
                         3130                       INC   A                              ; #888    cP         INACTIVE            ;check   for  inactive    data   area:   don’t  up date   ptr if  so
                         3131                       JR    Z,,L9                          ;tf PSW   is non-zero   area   is active:    update    channe!   data  ptrs
                         3132                       LD    A,[1X+0]                       ;get  CHW  in  A
                         3133                       AND   OCOH                           ;87  - BE   tn  A   = CHA
                         3134                       RLCA                                 ;form  CH¥   *  2   inaA,  t.e.,   the  offset   from
                         3135                       RLCA                                 ;PTR_TO  S ON_O    of  the   channel    data  area   pointer
                         3136                       RLCA  >THAT  POINTS    TO  CHANNEL    CH” 
                         3137                       LD    E,A                            ;add  offset   to addr  of  PTR_TO_S  ON_O
                         3138                       LD    0,0                            
                         3139                       LD    HL,PTR  TO   _SON  O           
                         3140                       ADD   HL,DE                          ;-HLpoints   to   proper   channel    data   area   pointer
                         3141                       PUSH  IX                             ;store  this  song   data  area’s   byte   O   addr    there
                         3142                       POP   DE                             
                         3143                       LD    [HL],€                         
                         3144                       INC   HL                             
                         3145                       LD    [HL],O                         
                         3146  
                         3147  ;       ENOIF
                         3148  
                         3149  ;       ¢ point   IX to  byte  O  next   song  data  area
                         3150  
                         3151  9                                                         
                         3152                       LD    DE,10                          
                         3153                       ADD   IX,DE                          
                         3154                       JR    L2                    -REPEAT  LOOP 
                         3155  
                         3156  DONESNOMAN                                                
                         3157                       POP   IX                             ;restore   Ix
                         3158  ;@@@ L112
                         3159                       RET                                  
                         3160  
                         3161  
                         3162  
                         3163  ;******************************
                         3164  ;*      LEAVE_EFFECT          *
                         3165  ;******************************
                         3166  
                         3167  ;LEAVEEFFECT,  called by a special sound effect routine when it’s finished,
                         3168  ;restores the SONGNO of the song to which the effect note belongs to B5 - BO  of
                         3169  ;byte 0 in the effect’s data area, and loads bytes 1 and 2 with the address  of
                         3170  ;the next note in the  song.  The address of the 1 byte SONGNO (saved by the
                         3171  ;effect when first called) is passed in DE.  The 2 byte address of the next note
                         3172  ;in the song, also saved by the effect, is passed in HL.  IX is assumed to  be
                         3173  ;pointing to byte O of the data area to which the song number is to be restored.
                         3174  ;Bits 7 and 6 of the saved SONGNO are ignored, and therefore may be used by the
                         3175  ;effect to store flag information during the course of the note.
                         3176  
                         3177  __EFFECT_OVER                                             
                         3178  ;@@@ LEAVEEFFECT
                         3179                       LD    [IXX+T4],B                     ;LSB NEXT_NOTEPTR     LSB addr next note  in song
                         3180                       LD    [IX+2],H                       ;MSB NEXTNOTE PTR  := MSB addr next note  in song
                         3181                       LD    A,[0E]             >= =X=XSONGNO [I,E,,THE SAVED,ORIGINAL  SONGNO] 
                         3182                       AND   O3FH               :® O O SONGNO 
                         3183                       LD    B,A                := 0 O SONGNO [B NOW = ORTGINAL SONGNO] 
                         3184                       LD    A,[1X+0],= CHA   62 [ALL EFFECT NOTES HAVE SONGNO  =  62] 
                         3185                       AND   0C0H                  CH¥ O00 0000 
                         3186                       OR    B                     CHA   SONGNO 
                         3187                       LD    [IX+0],A                       ;restore the song number
                         3188                       JR    EFXOVER                        
                         3189  
                         3190  
                         3191  
                         3192  ;eeeeeeeeereaeeseseeresereees
                         3193  ;*    PROCESS   DATA_AREA           *
                         3194  ;Steerer eserregeeseoeueeeeees
                         3195  
                         3196  ;See  Users’   Manual    for   description
                         3197  ;Terminology:     SFX   2  address    of  sound  effect     routine
                         3198  
                         3199  PROCESS              DATA_AREA                                
                         3200                       CALL  AREA_SONG_IS                   ;return    area’s    SONGNO     in A   [and   addr   SFX  in  HL]
                         3201                       CP    INACTIVE                       ;test   for   inactive     code
                         3202                       RET   Z                              ;RET,   no   processing      if  area   inactive
                         3203  
                         3204  ;         *  if special     effect,    call   it to   process     the  data   area
                         3205  
                         3206                       CP    62                             ;test   for   special     sound   effect
                         3207                       JR    NZ,L10                         ;1f  PSW    is zero    data   area   used   by  sound   effect
                         3208                       LD    DE,7                           ;pt  HLto    SFX+7,    starting    adr   of   the  effect’s     cod  e
                         3209                       ADD   HL,DE                          
                         3210                       JP    [HL ]                 -DO  1  PASS   THRU    EFFECT,RET   FROM   EFFECT 
                         3211  
                         3212  ;          ENDIF
                         3213  
                         3214  ;         * else   process     a non-effect     note
                         3215  
                         3216  L10                                                       
                         3217                       CALL  ATN_SWEEP                      ;process     atn  sweep    data,    if  any
                         3218                       CALL  FREQ  SWEEP                    ;proc   frq   sweep   data,     if any,    &  note  dura    timer  s
                         3219  ;         JR        NZ,L12                ;'f  PSW   {ts zero    note   is  over
                         3220                       RET   NZ                             
                         3221  EFXOVER                                                   
                         3222                       LD    A,[IX+O]                       ;A  := CH#                 this   note
                         3223                       PUSH  AF                             ;save  on    stack
                         3224                       CALL  LOAD_NEXT   NOTE               ;load  data    for   next   note
                         3225                       POP   BC                             ;B  := CHA       SONGNO    previous     note
                         3226                       LD    A,[1X+0]                       ;A  :® CHA#      SONGNO    new   note   [may   be  inactive]
                         3227                       CP    8                              ;check    against    new   note’s    CHé#     SONGNO
                         3228  ESE                  JR    Z,L12                 >1F  PSW   IS  NON-ZERO     CHANGE    TO/FROM     TONE/EFX/NOISE 
                         3229                       RET   Z                              
                         3230                       JR    UP_CH_DATA_PTRS                ;to  maintain     data   area    priority     system
                         3231  
                         3232  ;         ENDIF
                         3233  ;         END  SNOMAN
                         3234  
                         3235  
                         3236  
                         3237  ;eee  eeeeeereeeeeseseeeeseges
                         3238  ;*        LOAD  _NEXT  NOTE           .
                         3239  ;eeeeeseeeereseseeseeeeeeees
                         3240  
                         3241  ;see   Users’    Manual    for  description
                         3242  ;SFX   refers    to  the   beginning     address     of  a  special     sound   effect    routine
                         3243  
                         3244  LOAD_NEXT_NOTE                                            
                         3245  
                         3246  ;          *  deactivate     area,    save   SONGNO    on   stack
                         3247  
                         3248                       LD    A,[1X+0]                       ;A  :=  byte   O
                         3249                       AND   00111111B                      ;mask   CH#,    if  any
                         3250                       PUSH  AF                             ;save   SONGNO    on   stack
                         3251                       LD    [IX+O0],INACTIVE               ;deactivate      area
                         3252  
                         3253  ;          *  A  :®  header    new   note
                         3254  
                         3255                       LD    L,[1X+1]               -HL   := ADDR    NEW   NOTE    IN ROM 
                         3256                       LD    H,[1X+2]                       
                         3257                       LD    A,[HL]                -A   :=  HEADER    NEW   NOTE 
                         3258  
                         3259  ;          *  save   header    of  new   note   in  song    on  stack    and   load    its  data  CASE     note    type
                         3260  
                         3261                       LD    B,A                            ;save    header    new   note    in  B
                         3262                       BIT   5,A                            ;test    for   rest
                         3263                       JR    Z,L13                          ;1f   PSW   is  non-zero     note    is  a  rest
                         3264  
                         3265  ;@@@   REST
                         3266                       PUSH  BC                             ;save    header    on   stack
                         3267                       AND   000111118                      ;mask    al!   but   duration     bits
                         3268  
                         3269  ;          *  set   up NEXT_NOTE     PTR
                         3270  
                         3271                       INC   HL                             ;HL   =  address     of  the   header    of  the   note    after     this   note
                         3272                       LD    [IXX+T],B                      ;Store    in  NEXT_NOTE     PTR
                         3273                       LD    [1X+2],H                       
                         3274  
                         3275  ;          *  move   this   note’s    data   and   fill   in   bytes   where    necessary
                         3276  
                         3277                       LD    [ IX+ATN],OFOH                 ;set   atn   off
                         3278                       LD    [ IX+NLEN],A                   ;NLEN    :=  5  bit   duration
                         3279                       LD    [ IX+FSTEP],O                  ;indicate      freq   not   to  be  swept
                         3280                       LD    [ IX+ASTEP],0                  ;indicate      atn   not  to   be  swept
                         3281                       JP    MODBO                          
                         3282                       .                                    
                         3283  ;          ENOIF
                         3284  
                         3285  L13                                                       
                         3286                       BIT   4,8                    -TEST    FOR  END 
                         3287                       JR    Z,L14                          ;if  PSW    is  non-zero     end   of  song
                         3288                       BIT   3,A                            ;test    for   repeat
                         3289                       JR    2,ENONOREP                     ;1f  PSW    is  non-zero     repeat    song
                         3290  ;@@@   ENDREP
                         3291                       POP   BC                             ;B  :=  SONGNO
                         3292                       JP    JUKE  BOX                      ;to  reload     is*   note   of   this   song
                         3293  
                         3294  ;       RET                           ; to PROCESS  DATA   _AREA,  don’t   save  header
                         3295  ;       ENDIF
                         3296  
                         3297  ENONOREP                                                  
                         3298                       LD    A,INACTIVE                     
                         3299                       PUSH  AF                             ;Save   inactive   code   to end  song
                         3300                       JP    MODBO                          ;to  load  byte   O
                         3301  
                         3302  ;       ENDIF
                         3303  ;       -  test  for  special   sound  effect
                         3304  
                         3305  L14                                                       
                         3306                       AND   001111008           SMASK   IRRELEVANT    BITS 
                         3307                       CP    00000  1008                    ;test   for  BS  - B2  = OOO!
                         3308                       JR    NZ,L15                         ;1f  PSW  is  zero  note   is a  special   effect
                         3309  ;e@@ EFFECT
                         3310                       POP   IY                             ;TY  :=  SONGNO
                         3311                       PUSH  IY                             ;put  SONGNO   back  on  stack
                         3312                       PUSH  BC                             ;Save  header   on  stack   NEXT_NOTE  PTR    := SFX,  DE  :=  SFX
                         3313                       INC   HL                             ;-pt  HL  to  next  byte   [LSB  addr  SFX]
                         3314                       LD    E,[HT]                         ;-E  :*  LSB  SFX
                         3315                       LD    [IXX+1],€                      ;-put  LSB  of  SFX   in byte   1 of  SxDATA   ([NEXT_NOTE_PTR]
                         3316                       INC   HL                             ;"pt  HL  to  MSB  SFX
                         3317                       LD    D,[HL]                         ;-D  :=  MSB  SFX
                         3318                       LD    [IXX+2],D                      ;-put  MSB  SFX   in byte   2 of  SxDATA
                         3319                       INC   HL                             ;point   HL  to next   note  [after   this  new  note]
                         3320                       PUSH  IY                             ;A  :2 SONGNO
                         3321                       POP   AF                             
                         3322                       PUSH  DE                             ;1Y  :=  SFX
                         3323                       POP   IY                             
                         3324                       LD    DE,PASS1                       ;create   “CALL   [IV]"  with  RET  to  PASS1  by  storing
                         3325                       PUSH  DE                             ;PASS1  on  the  stack
                         3326                       JP    [LY]                           ;ist  7 bytes   SFX  will  save   addr  next  note  &  SONGNO
                         3327  PASS!                                                     
                         3328                       LD    DE,7                           ;in same   fashion,   create   a  “CALL  (1Y+7)*
                         3329                       ADD   IY,DE                          ;to allow   SFX  to  load   initial  values
                         3330                       LD    DE,MODBO                       ;RET   to  MODBO
                         3331                       PUSH  DE                             
                         3332                       JP    [IY]                           
                         3333  
                         3334  ;      ENDIF
                         3335  
                         3336  ;       - 1f  here,  note   is type  0  - 3
                         3337  
                         3338  L15                                                       
                         3339                       PUSH  BC                             ;Save   header   on  stack
                         3340                       LD    A,B                            ;A  :=  fresh  copy   header
                         3341                       AND   000000  1 1B                   ;mask   all  but  type  number
                         3342                       OR    A                              ;test   for  type  O
                         3343                       JR    NZ,L16              7          ;if PSW   is zero  note   is  type  O: fixed   freq  and  atn
                         3344  
                         3345  ;@ee TYPEO                                   ;5e@t up NEXT_NOTE   PTR
                         3346                       INC   HL                             ;next   note  [after   this  new  note]   ts 4 bytes   away,
                         3347                       INC   HL                             ;point   HL  to  it     .
                         3348                       INC   HL                             
                         3349                       INC   HL                             
                         3350                       LD    [IX+T],B                       ;put  addr    in NEXT_NOTE_PTR
                         3351                       LD    [IX+2],H                       
                         3352  
                         3353  ;          * move    new   note   data    and   fill   in  bytes   where    necessary
                         3354  
                         3355                       DEC   HL                             ;point   HL  back    to  ist  ROM   data    to  move,   NLEN
                         3356                       LD    DE,O5                          ;point   DE  to  destination:       bytes    5,  4,   and  3
                         3357                       CALL  DE TO  DEST                    
                         3358                       LD    BC  3                          ;move  3  bytes
                         3359                       LDDOR                                
                         3360                       LD    [IX+FSTEP],0O                  ;set  for   no  freq   sweep
                         3361                       LD    [IX+ASTEP],0                   ;set  for   no  atn   sweep
                         3362                       JR    MODBO                          
                         3363  
                         3364  ;          ENDIF
                         3365  
                         3366  Li6                                                       
                         3367                       CP    1                              ;test  for   type    1
                         3368                       JR    NZ,L17                         ;if  PSW  is  zero    note   is   type   1:  swept
                         3369                                                            ;  freq,   fixed    attenuation
                         3370  ;e@e@   TYPE!                                         ;  set  up   NEXT_NOTE    PTR
                         3371                       LD    DE,6                    :NOTE  AFTER    THIS   NOTE    IS  6 BYTES    AWAY, 
                         3372                       ADD   HL,DE                          ;pt  HL  to  it
                         3373                       LD    [IX+T],B                       ;Store    in  NEXT_NOTE    PTR
                         3374                       LD    [IX+2],H                       
                         3375  
                         3376  ;          *  move    new  note    data    and  fill    in bytes    where    necessary
                         3377  
                         3378                       DEC   HL                             ;point   HL   back   to   ist  ROM   data   to   move,   FSTEP
                         3379                       INC   E                              ;E;  point    DE  to  destination:       bytes    7   - 3
                         3380                       CALL  DE TO  DEST                    
                         3381                       LD    BC,5                           ;move   5  bytes
                         3382                       LDDR                                 
                         3383                       LD    [IX+ASTEP],0                   ;set   for  no   atn  sweep
                         3384                       JR    MODBO,                         
                         3385  
                         3386  ;          ENDIF
                         3387  
                         3388  117                                                       
                         3389                       CP    2                              ;test   for   type   2                                 
                         3390                       JR    NZ,TYPE3                       ;if  PSW   is  zero   note    is  type   2:   fixed    freq,  swept  attenvation
                         3391  ;@e@e   TYPE2                                         ;set   up  NEXT  _NOTE  PTR
                         3392                       LD    DE,6                           ;pt  HL  to   note   after    this   note,    since    it’s  6 bytes   away,
                         3393                       ADD   HL,DE                          ;pt  HL  to   it  by  adding    6
                         3394                       POP   AF                             ;A  :=  header    this   note   [CH¢      SONGNO   }
                         3395                       PUSH  AF                             ;put   back   on  stack
                         3396                       AND   110000008                      ;mask   SONGNO,     leaving    CHA
                         3397                       JR    NZ,L18                         ;1f  PSW   is  zero   this    its a  noise   note,     which  is  only  5  ROM    bytes     iong
                         3398                       DEC   HL                             ;SO  move   HL  back    1 byte
                         3399  
                         3400  ;          ENDIF
                         3401  
                         3402  118                                                       
                         3403                       LD    [IX+1],T                       ;put   addr   in  NEXT_NOTE_PTR
                         3404                       LD    [1X+2],H                       
                         3405  
                         3406  ;          *  move    new  note   data     and  fill   int      ‘s  where   necessary
                         3407  
                         3408                       DEC   HL                             ;pointHi back   to  ist  ROM  data   to move,  APS
                         3409                       LD    E,9                            ;point DE to  destination:     bytes   9,8,5  - 3
                         3410                       CALL  DETO DEST                      
                         3411                       LD    BC,2                           ;move 2 bytes
                         3412                       LDDR                                 ;when done,  DE  points   to  FSTEP,   HL to  ROM NLEN
                         3413                       XOR   A                              
                         3414                       LD    [DE],A                         ;FSTEP := O  for  no  freq  sweep
                         3415                       DEC   DE                             ;pt DE to RAM   NLEN
                         3416                       DEC   DE                             
                         3417                       LD    C,3                            ;     last  3 ROM  bytes    if this   is a noise  note,   garbage
                         3418                       LDDR                                 ;will be loaded   into   byte  3,  buts  that’s  OK
                         3419                       JR    MODBO                          
                         3420  
                         3421  ;        ENOIF
                         3422  
                         3423  ;       if here,   note  is  type  3:  swept fred,  swept   attenuation
                         3424  
                         3425  TYPE3                                                     ;set up NEXT NOTE   PTR
                         3426                       LD    DE,8                           ;snoteafter  this  note   is  8 bytes   away,
                         3427                       ADD   HL,DE                          ;pt HL to  it
                         3428                       LD    [IXX4+4],0                     ;put addr  in NEXT_NOTE   PTR
                         3429                       LD    [1X+2],H                       
                         3430  
                         3431  ;       * move  new  note  data   and  fill in bytes   where   necessary
                         3432  
                         3433                       DEC   HL                             ;point HL back   to  ist  ROM  data   to move,  APS
                         3434                       PUSH  ~=E'IK                         ;point DE to  destination:     bytes   9 - 3
                         3435                       POP   IY                             ;I1Y:= addr  byte  O   [and DE  =  6]
                         3436                       INC   E                              ;DE  :9
                         3437                       ADD   IY,DE                          ;IY  :=addr  byte  9   [APS]
                         3438                       PUSH  LY                            A 
                         3439                       POP   DE                             ;DE  :=addr  APS
                         3440                       LD    BC,7                           ;move 7 bytes
                         3441                       LDDR                                 
                         3442  
                         3443  ;       * modify   byte O  basis   header  new note
                         3444  
                         3445  MODBO                                                     
                         3446                       PUSH  IX                             ;pt HL to byte   O
                         3447                       POP   HL                             
                         3448                       POP   AF                             ;A := header  new  note
                         3449                       POP   BC                             ;B :2=SONGNO                                             
                         3450                       CP    INACTIVE            -TEST FOR  INACTIVE    [SONG  OVER,AS DETECTED   ABOVE] 
                         3451                       RET   Z                              
                         3452                       LD    D,A                            ;save header   in D
                         3453                       AND   3FH                            ;Rid channel  bits
                         3454                       CP    04                  -SPECIAL EFFECT 
                         3455                       JR    NZ,L20_ LOAD  _NEX             
                         3456                       LD    B,62                           
                         3457  
                         3458  L20_LOAD_NEX:                                             
                         3459                       LD    A,D                            ;restore A  to  header
                         3460                       AND   OCOH                -A  :=CHA    GOQOOO0OO00O 
                         3461                       OR    B                              ;A  :=mew CH#     SONGNO
                         3462                       LD    [HL],A                         ;store back  in  byte  O
                         3463  
                         3464  ;         ENDIF
                         3465  
                         3466  ;@ee@ 119
                         3467                       RET                                  
                         3468  
                         3469  DETO_DEST                                                 ;DE  passed = offset  from byte  0,  RETed w  addr  byte  offset
                         3470                       PUSH  _—IX                           
                         3471                       POP   IY                             ;1Y     addr byte  O [and DE  = offset]
                         3472                       ADD   IY,DE                          ;1Y     addr byte  O + offset
                         3473                       PUSH  —SI‘TY                         
                         3474                       POP   DE                             ;DE     addr of destination   byte  in SxDATA
                         3475                       RET                                  
                         3476  
                         3477                       END   LOADNEX                        
                         3478  
                         3479  
                         3480  ;5 rrr                      rr      re        rrre  ee ee  ee   eee  ee eeee ee   eee
                         3481  ;
                         3482  ;  Out_to_sound_    port
                         3483  ;                   input:   a=sound   port   data  to  output
                         3484  ;                  register    usage:  n.a.
                         3485  ;
                         3486  OUT_TO_SOUND_PORT:                                        
                         3487                       PUSH  BC                             ;SAVE  BC
                         3488                       LD    B,A                            ;THE  IDEA   IS  TO  GET  THE
                         3489                       LD    A,[SOUNDPORT ]              —  ; INDIRECT    PORT  ADDRESSING
                         3490                       LD    C,A                            ;THRU  THE   PORT   TABLE  IN   EOS
                         3491                       OUT   [C],8                          
                         3492                       LD    A,B                            
                         3493                       POP   BC                             
                         3494                       RET                                  
                         3495  ;
                         3496  ;,SSRSHS ST SSSR  SSSCESTESTSS  SSSSS SSSSS SSS SSSSS SSS STS SSS  SsSlsessSessssrze
                         3497  ;»SSSSSSSSESSSSSSPSSSSESSSSSSSSS       SSS SPSSTssssssescssessssssezseeszer=2et2zee2
                         3498  ;,BBSSPSSSSECTPTPSFESSSSSSSSSSP SHSSS STSST SSSSSSSSTessersersesstestsseeexse22eze22222
                         3499  ;
                         3500  
                         3501  
                         3502                                                            ;GLB         _  QUERY    FILE,       SET    FILE,      MAKE    FILE
                         3503                                                            ;GLB         __FILE    QUERY
                         3504                                                            ;EXT          FCB  _HEAD   _ADDR,FCB_       DATA_ADOR
                         3505                                                            ;EXT          SCAN_FOR_FILE
                         3506                                                            ;EXT         BLOCKS    REQ,USER        BUF   ,USER    NAME
                         3507                                                            ;EXT         BUF  START    ,BUF    END
                         3508                                                            ;EXT         STRCMP    ,BASECMP
                         3509                                                            ;EXT         NEW   HOLE   SIZE,NEW         HOLE   START,HOLE        FILE    NAME
                         3510                                                            ;EXT         EOS   YEAR,EOS      MONTH,EOS        DAY
                         3511                                                            ;EXT         BLK_STRT_PTR,VOL            BLK   S2           -DLS(8/29/83)
                         3512                                                            ;EXT         READ_BLOCK.,WRITE           BLOCK,CHECK        IF   OIRECTORY
                         3513                                                            ;EXT         DIR_BLOCK_NO,FOUND             AVAIL    ENTRY
                         3514                                                            ;EXT         FILENAME     CMPS
                         3515  
                         3516  ;-------------------------------------------------------------------------------------------------
                         3517  ;
                         3518  ;  __QUERY_FILE -- Read the file’s directory entry.  (USES STRCMP FOR FILE NAME COMPARISIONS)
                         3519  ;  __FILE_QUERY -- SAME AS ABOVE BUT SETS UP SCAN_FOR_FILE FOR BASE COMPARES ( USES BASECMP )
                         3520  ;
                         3521  ;  CALLING PARAMETERS:        Device number in A
                         3522  ;                             address of name string in DE
                         3523  ;                             address of buffer in HL
                         3524  ;
                         3525  ;  EXIT PARAMETERS:       if no errors -- Z = 1;  A = 0; BCDE = file’s start block:
                         3526  ;                                  directory entry in caller’s buffer
                         3527  ;                         if errors    -- Z = 0;  A = error code;  DE =  junk;
                         3528  ;                                  caller’s buffer undefined
                         3529  ;
                         3530  ;-------------------------------------------------------------------------------------------------
                         3531  
                         3532  __FILE_QUERY:                                             
                         3533                       SCF                                  ;  THIS    ENTRY    DOES    NOTHING      MORE     THAN    SET   CARRY     FLAG
                         3534                       JR    QUEER,                         
                         3535  
                         3536  __QUERY_FILE                                              
                         3537                       SCF                                  ;  THIS    ENTRY     CLEARS     CARRY     FLAG
                         3538                       CCF                                  
                         3539  QUEER:                                                    
                         3540                       PUSH  HL                             ;SAVE     REG’‘S
                         3541                       PUSH  IX                             
                         3542  
                         3543                       PUSH  AF                                              ] 
                         3544  
                         3545                       JR    C,SET     UP_A      -          ;  DID    WE  COME     IN  AT   FILE   QUERY
                         3546  
                         3547                       XOR   A                              ;  USE   STRCMP     FOR    FILE    NAME     COMPARE
                         3548  SET_UP_A:            !                                    
                         3549                       LD    [FILENAME_CMPS],A              ;  O  =  COMPARE      COMPLETE       FILE    NAME
                         3550                                                            ;  NOT   O   -  COMPARE      ONLY    THE    BASE
                         3551                       POP   AF                             
                         3552  
                         3553                       LD    [USER_BUF  ],HL                ;SAVE     USER’S     DATA    ADDRESS
                         3554  
                         3555                       LD    IX,[FCB_HEAD      ADDR]        ;POINT     TO   SYSTEM’S       FCB
                         3556                       LD    H,D                            ;GET    NAME    POINTER      IN   HL
                         3557                       LD    L,E                            
                         3558                       CALL  SCAN_FOR_FILE                  ;LOOK     IN  TH’     ‘RECTORY
                         3559                       JR    NZ,Q_ERROR                     ;BRANCH IF ERROR RETURNED
                         3560  
                         3561                       PUSH  DE              >SAVE START BLOCK OF FILE 
                         3562                       PUSH  BC                             
                         3563  
                         3564                       LD    DE,[USERBUF ]                  ;GET BUFFER ADDRESS IN DOE
                         3565                       LD    L,[1IX+FCPOINTER]              ;GET ADDR OF ENTRY IN  HL
                         3566                       LD    H,[IX+FCB_POINTER+1]           
                         3567                       LD    BC,OIR_ENT_LENGTH-3            ; SET BYTE COUNT TO  LOAD  ONLY  VALID INFO  THAT
                         3568                                                            ; THAT WAS STORED ON THE  DEVICE
                         3569  
                         3570                       LDIR                                 ;COPY DATA TO CALLER’S BUFFER
                         3571  
                         3572                       POP   BC                             ;GET FILE’S START BLOCK
                         3573                       POP   DE                             
                         3574  
                         3575                       XOR   A                              ;SHOW NO ERROR
                         3576                       LD    [FILENAME_CMPS],A              ; DEFAULT FOR SCAN FOR  FILE
                         3577  Q_ERROR:                                                  
                         3578                       POP   IX                             ;sRESTOREREG‘S
                         3579                       POP   HL                             
                         3580                       RET                                  
                         3581  
                         3582  
                         3583  ;-----------------------------------------------------------------
                         3584  ;
                         3585  ;  _SET_FILE    --   Re-write the file’s directory entry.
                         3586  ;
                         3587  ; CALLING  PARAMETERS:      Device number in A
                         3588  ;                           address of name string in DE
                         3589  ;                           address of buffer in HL
                         3590  ;
                         3591  ; EXIT  PARAMETERS:      tf no  errors    --  Z = 1; A = 0;
                         3592  ;                             directory entry updated
                         3593  ;                        if errors        --  Z = 0; A =  error code;
                         3594  ;                             directory entry unchanged
                         3595  ;
                         3596  ;-----------------------------------------------------------------
                         3597  
                         3598  _SET_FILE                                                 
                         3599                       PUSH  BC                             ;SAVE  REG’S
                         3600                       PUSH  DE                             
                         3601                       PUSH  HL                             
                         3602                       PUSH  IX                             
                         3603                       LD    [USER BUF],HL                  ;SAVE  ADDR  OF   USER’S   DATA
                         3604  
                         3605                       LD    IX,[FCB_HEAD_ADDR]             ;POINT  TO  SYSTEM’S     FCB
                         3606  
                         3607                       LD    H,D                            ;GET  STRING   ADDRESS    IN  HL
                         3608                       LD    AE                             
                         3609                       CALL  SCAN_FOR  FILE                 ;GET  THE  DIR  ENTRY
                         3610                       JR    NZ,S_ ERROR                    ;BRANCH   IF ERROR
                         3611  
                         3612                       LD    HL,[USER  BUF  ]               ;GET  BUFFER   ADDRESS
                         3613                       LD    E,[IX+FCB_   POINTER]          ;GET  ENTRY  ADDR    IN  DE
                         3614                       LD    D,[IX+FCB_POINTER+1]           
                         3615                       LD    BC,DIR_ENT_LENGTH-3            ;SET BYTE   COUNT
                         3616                       LDIR                                 ;COPY  THEIR   BUFFER   TO   BLOCK   BUFFER
                         3617  
                         3618  TAPE_TIMED_OUT:                                           
                         3619                       LD    A,[IX+FCB_DEVICE]              ;SET   DEVICE  NUMBER
                         3620                       LD    HI,[FCB_DATA_ADOR]             ;GET  ADDR  OF  MY  BUFFER
                         3621                       LD    E,[IX+FCB_BLOCK]               ;GET  BLOCK   ADDRESS    IN  BCDE
                         3622                       LD    D,[IX+FCB_BLOCK+1]             
                         3623                       LD    C,[IX+FCB_BLOCK+2]             
                         3624                       LD    B,[1X+FCB_BLOCK+3]             
                         3625                       CALL  WRITE_BLOCK                    ;RE-WRITE   THE   DIRECTORY     BLOCK
                         3626  
                         3627                       JR    NZ,WRITE_ERRORS                
                         3628                       XOR   A                              ;SHOW  NO  ERRORS
                         3629  
                         3630  WRITE                ERRORS:                                
                         3631  SERROR                                                    
                         3632  
                         3633                       POP   IX                             ;RESTORE   REG‘S
                         3634                       POP   HL                             
                         3635                       POP   DE                             
                         3636                       POP   BC                             
                         3637                       RET                                  
                         3638  
                         3639  
                         3640  ;---------------------------------------------------------------------------------
                         3641  ;
                         3642  ;  _MAKE_FILE: creates a file in the directory.
                         3643  ;
                         3644  ;  ENTRYPARAMETERS:   called with device ID in A:  address of name
                         3645  ;                  string in HL;  file size (in bytes) in BC DE.
                         3646  ;
                         3647  ;   NOTE:    IF FILE SIZE = O (BC DE), THEN THE REMAINDER OF THE TAPE IS
                         3648  ;            ALLOCATED TO THE FILE
                         3649  ;
                         3650  ;  EXIT PARAMETERS:  CONDITION   FLAGS
                         3651  ;                       Z    -   NO  ERRORS
                         3652  ;                      NZ    -   ERRORS
                         3653  ;                                 A  = ERROR CODE
                         3654  ;
                         3655  ;        ALL REGISTERS ARE PRESERVED EXCEPT AF
                         3656  ;
                         3657  ;---------------------------------------------------------------------------------
                         3658  
                         3659  FOUND_ENTRY          EQU   0                              ; BIT   INOICATING   DELETED   FILE FOUND  FOR  OVERLAYING
                         3660  
                         3661  _MAKE_FILE                                                
                         3662                       PUSH  IY                             ;SAVE  REGISTERS
                         3663                       PUSH  IX                             
                         3664                       PUSH  HL                             
                         3665                       PUSH  DE                             
                         3666                       PUSH  BC                             
                         3667  
                         3668                       LD    IX,[FCB_HEAD_ADDR]             ;POINT  TO  SYSTEM   FCB
                         3669                       LD    [IX+FCB_MODE],0         >  INIT  IT IN  CASE   IT WAS SET 
                         3670  
                         3671                       LD    [IX+FCB_DEVICE],A              ;SAVE  DEVICE  NUMBER
                         3672                       LD    [USER_NAME],HL                 ;SAVE  POINTER   TO  NAME
                         3673  
                         3674                       LD    A,B                            ; CHECK   IF TO  ALLOCATE   REST  OF TAPE
                         3675                       OR    C                              
                         3676                       JR    NZ,GOT_ FILE SIZE              ; NOPE,  GOT  SIZE
                         3677  
                         3678                       LD    A,E                            
                         3679                       OR    D                              
                         3680                       JR    NZ,GOT FILE  SIZE              
                         3681                       SET   MODEREMAINDER   _BIT,[IX+FCB_   MODE] ;  FLAG  IT
                         3682  
                         3683                       JR    SET_UP_DIR                     
                         3684  
                         3685  
                         3686  ;   SINCE  WE ARE  CALLED  WITH  A BYTE  COUNT,   DIVIDE  IT  BY  1024
                         3687  ;   (SHIFT  RIGHT  10 BITS)  TO  GET  A BLOCK  COUNT.
                         3688  
                         3689  GOT_FILE_SIZE:                                            
                         3690                       LD    E,D                            ;D0  A QUICK   SHIFT  BY  8
                         3691                       LD    D,C                            
                         3692                       LD    C,B                            
                         3693                       LD    B,O                            
                         3694                       SRL   C                              ;SHIFT  ONE  MORE
                         3695                       RR    D                              
                         3696                       RR    E                              
                         3697                       SRL   CC                             ;THEN  ONE   LAST   TIME
                         3698                       RR    A]                             
                         3699                       RR    E                              
                         3700  
                         3701  ; FOR THIS   TO BE  A LEGAL   FILE   SIZE,   IT  MUST  FIT   INTO  DE.
                         3702  
                         3703                       LD    A,C                            ;CHECK   FOR  TOO  BIG
                         3704                       OR    A                              
                         3705                       JP    NZ,TOO  BIG                    ;JUMP   IF TOO   BEEG,   SENOR
                         3706                       INC   DE                             ;ROUND   UP  IN  CASE  THERE   WAS   A FRACTION
                         3707                       LD    A,E                            ;CHECK   FOR  TOO  BIG  AGAIN
                         3708                       OR    D                              
                         3709                       JP    Z2,T0BIG                       
                         3710                       LD    [BLOCKS  REQ],DE               ;ELSE  SAVE   THE  BLOCK   COUNT
                         3711  
                         3712  SET_UP_DIR:                                               
                         3713                       LD    DE,O                           ; ZERO  OUT   HI  ADDRESS
                         3714                       LD    [BLOCKS  _REQ+2],DE            
                         3715                       LD    [DIR_BLOCK_NO],DE              
                         3716                       XOR   A                              
                         3717                       LD    [FOUND_AVAIL_ENTRY],A          
                         3718  
                         3719                       LD    [IX+FCB_BLOCK],1               ;INIT  NUMBER    OF  FIRST   DIR  BLOCK
                         3720                       LD    [IX+FCB_BLOCK+1],A          ZERO   IT  OUT 
                         3721                       LD    [IX+FCB_BLOCK+2],A             
                         3722                       LD    [IX+FCB_BLOCK+3],A             
                         3723  
                         3724                       LD    [IX+FCB_START_BLOCK],1         ;INIT  NUMBER    OF  FIRST   DIR  BLOCK
                         3725                       LD    [IX+FCB_START_BLOCK+1],A       
                         3726                       LD    [IX+FCB_START   BLOCK+2],A     
                         3727                       LD    [IX+FCB_START   BLOCK+3],A     
                         3728  
                         3729                       LD    DE,[FCB_DATA_ADDR]             ;INIT   POINTER    TO BUFFER
                         3730                       LD    [IX+FCB_POINTER],€             
                         3731                       LD    [IX+FCB_POINTER+1],0           
                         3732  
                         3733                       LD    [BUF_START],DE                 ;ALSO   INIT   HERE  WITH   SAME
                         3734                       LD    HL,1024                        ;CALC   ADDR   OF  END  OF  BUFFER   TOO
                         3735                       ADD   HL,DE                          
                         3736                       LD    [BUF_END],HL                   ;AND   SAVE  IT
                         3737  
                         3738  ;THIS LABEL   NOT  USED  IN THIS   ROUTINE,    NOT  DECLARED    GLOBAL
                         3739  ;REMOVED  BECAUSE   IT CONFLICTS    WITH   IDENTICAL    LABEL   ELSEWHERE
                         3740  ;READ_TIMEOUT:
                         3741                       LD    A,[IX+FCB_DEVICE]              ;GET  PARAMETERS     FROM  FCB
                         3742                       LD    L,[IX+FCB_POINTER]             
                         3743                       LD    H,[IX+FCB  POINTER+1]          
                         3744                       LD    E,[IX+FCB  BLOCK]              
                         3745                       LD    0,[1X+FCB_BLOCK+1]             
                         3746                       LD    C,[IX+FCB_BLOCK+2]             
                         3747                       LD    B,[IX+FCB_BLOCK+3]             
                         3748                       CALL  READBLOCK                      ;THEN   READ   THE  FIRST   BLOCK
                         3749  
                         3750                       JP    NZ,MAKE_ERROR                  IF  ERROR 
                         3751  
                         3752  SET_UP_FCB:                                               
                         3753                       LD    IY,[FCB _DATA_ADDR]            ;POINT       THE  BUFFER
                         3754  
                         3755                       LD    A,[IY+VOL_DIRSIZE]             ;GET   THE   DIR  SIZE    BYTE
                         3756                       AND   7FH                            ;ZERO   THE   PERM   BIT
                         3757                       INC   A                        :BECAUSE    WE   START    IN  BLOCK    1 
                         3758                       DEC   A                              ;TO  SOLVE    PICKET    FENCE    PROBLEM
                         3759                       LD    LIX+FCB_LAST       BLOCK],A    ;SET   THE   LAST   BLOCK    #
                         3760                       LD    [IX+FCB_LAST_BLOCK+1],0        ;OTHER    BYTES    WILL   BE  ZERO
                         3761                       LD    [ IX+FCB_LAST_BLOCK+2],0       
                         3762                       LD    [I1X+FCB_LAST_BLOCK+3],0       
                         3763  
                         3764                       CALL  CHECK_IF_DIRECTORY             ;  CHECK    IF  DIRECTORY     EXISTS
                         3765                       JP    NZ,MAKE_ERROR                  
                         3766  
                         3767                       LD    B,ENT_PER_BLOCK-       1       ;INIT   ENTRY    COUNT,    ALLOW   FOR   vOL   ID
                         3768  
                         3769  NEXT_ENT                                                  
                         3770                       LD    L,[IX+FCB_POINTER]             ;GET   CURRENT    POINTER
                         3771                       LD    H,[IX+FCB_POINTER+1]           
                         3772                       LD    DE,DIR_ENT_LENGTH              ;GET   LENGTH     OF  AN  ENTRY
                         3773                       ADD   HL,DE                          ;ADVANCE    POINTER     TO  NEXT   ENTRY
                         3774                       LD    [IX+FCB_POINTER],L             ;AND   SAVE   IT  AGAIN
                         3775                       LD    [IX+FCB_POINTER+1],H           
                         3776  
                         3777  CHECK_ENT                                                 
                         3778                       LD    L,[IX+FCB_POINTER]             ;GET   POINTER    INTO    IY  THE   LONG   WAY
                         3779                       LD    H,[IX+FCB_POINTER+1]           
                         3780                       PUSH  HL                             
                         3781                       POP   IY                       SFT!  
                         3782  
                         3783                       LD    A,[IY+DIR_ATTR]                ;GET   THE  ATTRIBUTE      BYTE   FOR   THIS   ENTRY
                         3784                       LD    C,A                            ;SAVE   IT  HERE    FOR  NOW
                         3785                       BIT   ATTR_HOLE     BIT,A            ; CHECK    IF  HOLE
                         3786                       JP    NZ,FOUND  _HOLE                ;BRANCH    IF   IT‘S   A  HOLE!!!    << ewereaxaz
                         3787  
                         3788                       BIT   MODE  REMAINDER      BIT,[IX+FCB_MODE] ;  DO  WE   ALLOCATE     REST   OF   TAPE?
                         3789                       JR    NZ,0_FILE                      ; YUP,   DON’T    BOTHER    CHECKING
                         3790  
                         3791                       BIT   ATTR_DEL_BIT,C                 ;IS  IT  A  DELETED     FILE?
                         3792                       JR    Z,ACTIVE    FILE               ;NOPE,   AN   ACTIVE   ONE
                         3793  
                         3794  ;             LET’S     LOOK   FOR   DELETED     FILE   TO  USE
                         3795  
                         3796                       LD    L,[1¥+DIR_MAX_LENGTH]          ;  GET   ALLOCATED     SIZE
                         3797                       LD    H,[IY+DIR_MAX_LENGTH#1]        
                         3798  
                         3799                       LD    DE,[BLOCKS   REQ]              ;  MIN  NO  OF   BLOCKS    NEEDED
                         3800                       OR    A                              ;clear    carry    flag
                         3801                       SBC   HL,DE                          ;  WILL   WE  FIT?)
                         3802                       JR    C,D  FILE                      ;  NOPE,   LOOK    FOR  ANOTHER     ENTRY
                         3803  
                         3804                       LD    HL,FOUND   AVAIL    _ENTRY,FLAG   BYTE 
                         3805                       BIT   FOUND_ENTRY,[HL]               ;  DO  WE  ALREADY     HAVE   FIRST    FIT?
                         3806                       JR    NZ,D_FILE                              YUP,DON’T    EVEN   CONSIDER     THIS   ONE 
                         3807  
                         3808                       SET   FOUND_ENTRY,[HL  ]             
                         3809                       LD    E,[1X+FCB_BLOCK]               ;GIT   BLOCK   NO   OF  THIS   DIRECTORY
                         3810                       LD    D,[1X+FCB_BLOCK+1]             
                         3811  
                         3812                       LD    [OIR_BLOCK_NO],DE              ; SAVE  IT
                         3813                       JR    D_FILE                         
                         3814  
                         3815  
                         3816  ; IF THIS  IS  A REAL FILE,  WE  CAN  SEE  IF  ITS NAME MATCHES    THE
                         3817  ; ONE  WE ARE  ABOUT TO MAKE   --  IT’S AN  ERROR  IF SO.
                         3818  
                         3819  ACTIVE_FILE:                                              
                         3820                       LD    E,[IX+FCB_ POINTER]            ;POINT TO  THIS  ENTRY
                         3821                       LD    OD[IX+FCB_POINTER+1]           
                         3822                       LD    HL,[USER_NAME]                 ;POINT  TO DESIRED  NAME
                         3823                       CALL                                 ;COMPARE  THE  BASE OF  THE   FILENAMES
                         3824                       JP    Z,FILE_EXISTS                  ;BRANCH   IFTHEY’RE   THE  SAME
                         3825  DFILE                                                     
                         3826                       DJNZ  = NEXT_ENT                     ;ELSE  GO TO NEXT  ENTRY   (IF  IT  EXISTS)
                         3827  
                         3828                       LD    HL,[BUF_START]                 ;IF NOT  RESET  FCB  FOR NEXT   BLOCK
                         3829                       LD    [IX+FCB_POINTER],L             
                         3830                       LD    [IX+FCB_POINTER+1],H           
                         3831                       INC   [IX+FCB_BLOCK]                 ;INC  THE BLOCK  -- NO  CARRY   OUT
                         3832  
                         3833  ; DO 4-BYTE   COMPARE OF FCB BLOCK    VS FCB_LAST  BLOCK   TO SEE
                         3834  ; IF THERE’S   MORE FILE LEFT.
                         3835  
                         3836                       LD    A,[IX+FCB_LAST_BLOCK+3]        ;COMPARE MS  BYTES
                         3837                       CP    [IX+FCB_BLOCK+3]               
                         3838                       JP    C,FULL_DIR                     ;BRANCH  IF BLOCK   IS LARGER
                         3839                       LD    A,[IX+FCB_LAST_BLOCK+2]        ;COMPARE  NEXT  BYTES
                         3840                       CP    [IX+FCB_BLOCK+2]               
                         3841                       JP    C,FULL_DIR                     ;BRANCH  IF BLOCK   IS LARGER
                         3842                       LD    A,[IX+FCB_LAST_BLOCK+1]        ;COMPARE  NEXT  BYTES
                         3843                       CP    [IX+FCB_BLOCK+1]               
                         3844                       JP    C,FULL_DIR-                    ;BRANCH  IF BLOCK  IS  LARGER
                         3845                       LD    A,[IX+FCB_LAST_BLOCK+0]        ;COMPARE  LS  BYTES
                         3846                       CP    [1X+FCB_BLOCK+0]               
                         3847                       JP    C,FULL_DIR                     ;BRANCH  IF BLOCK  IS  LARGER
                         3848  ; IF WE  FALL  OUT, FCB_BLOCK  <=  FCB_LAST  BLOCK.
                         3849  DOREAD               AGAIN:                                
                         3850  
                         3851                       LD    A,[IX+FCB_DEVICE]              ;SET  UP THE  PARAMETERS
                         3852                       LD    L,[IX+FCB_POINTER]             
                         3853                       LD    H,[IX+FCB_POINTER+1]           
                         3854                       LD    E,[IX+FCB_BLOCK]               
                         3855                       LD    D,[1X+FCB_BLOCK+1]             
                         3856                       LD    C,[IX+FCB_BLOCK+2]             
                         3857                       LD    B,[IX+FCB_BLOCK+3]             
                         3858                       CALL  READ_BLOCK                     ;AND READ  THE  NEXT BLOCK   OF  ENTRIES
                         3859                       JP    NZ,MAKE_ERROR                  ; NOPE,  A REAL  ERROR
                         3860  
                         3861  NOTIMEOUT:                                                
                         3862                       LD    B,ENTPER  BLOCK                ;SET  THE ENTRY  COUNTER
                         3863                       JP    CHECK_ENT                      ;AND GO  CHECK  THE NEW  ENTRY
                         3864  
                         3865  FULLDIR:                                                  
                         3866                       LD    HL,FOUND AVAIL  _ENTRY         
                         3867                       BIT   FOUND_ENTRY,[HL]               ‘E WE FOUND   AN  ENTRY? 
                         3868                       JP    Z,FULL_DIR_EXIT                ; NOPE,  EXIT
                         3869                       JR    USE_ENTRY                      ; YUP,  CREATE   NEW   ENTRY    THERE
                         3870  
                         3871  ; ARRIVE   HERE   WHEN  WE’VE   FOUND   THE  HOLE   ENTRY   IN  THE  OIRECTORY.
                         3872  ; IV  IS  STILL   POINTING   TO  THE  ENTRY    IN  THE  BUFFER.
                         3873  
                         3874  FOUND_HOLE                                                
                         3875                       LD    HL,FOUND  _AVAIL_ENTRY         
                         3876                       BIT   FOUND ENTRY,[HL]               ; HAVE  WE  FOUND    A DELETED     ENTRY   WE  COULD  USE?
                         3877                       JR    Z,USE_HOLE                     ; NOPE,  STICK    IT  IN  THE   END
                         3878  
                         3879  USE                  ENTRY:                                
                         3880                       RES   FOUND_ENTRY,[HL ]              ; RESET  FOR   NEXT   TIME
                         3881  
                         3882                       LD    L,[1X+FCB_BLOCK]               ; GET THE   CURRENT    BLOCK                                                             '
                         3883                       LD    H,[IX+FCB_BLOCK+   1]          
                         3884  
                         3885                       LD    DE,[OIR_BLOCK_NO]              ; BLOCK  NO  WHERE    WE  HAVE   ENTRY    TO  USE
                         3886                       OR    A                              ;Clear  carry   flag
                         3887                       SBC   HL,DE                          ; SAME  BLOCK?
                         3888  
                         3889                       LD    HL,[BUF  START]                ; POINT  TO  START    OF  BLOCK
                         3890                       LD    [IX¢FCB_ POINTER],L            
                         3891                       LD    [IX+FCB_POINTERT1],H           
                         3892                       )                                    
                         3893                       JR    Z,GOT_BLOCK                    ; YUP,  DON’T    NEED   TO  READ   IN   ANOTHER   BLOCK
                         3894  
                         3895                       LD    [IX+FCB_BLOCK],E               ;  GET THIS   BLOCK
                         3896                       LD    [IX+FCB_BLOCK+1],D             
                         3897  
                         3898                       LD    BC,O                           
                         3899                       LD    A,[IX+FCB_DEVICE    ]          ;  DEVICE  ID
                         3900  
                         3901                       CALL  READ_BLOCK                     
                         3902                       JP    NZ,MAKE ERROR                  
                         3903                       JR    GOT_BLOCK                      ;  READ  IN  NEW  DIRECTORY
                         3904  
                         3905  NEXT_DIR:                                                 
                         3906  TOOSMALL:                                                 
                         3907                       LD    L,[IX+FCB_POINTER]             ;  GET POINTER    TO  DIR   ENTRY
                         3908                       LD    H,[IX¢FCB_POINTER+1]           
                         3909  
                         3910                       LD    DE,OIR_ENT_LENGTH              ;  LENGTH  OF   ENTRY
                         3911  
                         3912                       ADD   HL,DE                          ;  POINT  TO  NEXT   ENTRY
                         3913  
                         3914                       LD    [IX+FCB_POINTER],L             
                         3915                       LD    [1X+FCB_POINTER+1],H           
                         3916  
                         3917  GOTBLOCK:                                                 
                         3918                       PUSH  HL                             
                         3919                       POP   IY                             
                         3920  
                         3921                       BIT   ATTRDEL   BIT,[1Y+#DIR   ATIR] ;  IS  IT  DELETED?
                         3922                       JR    Z,NEXT_DIR                     ; NOPE,    LOOK   FOR   ANOTHER   DLETED    ENTRY
                         3923  
                         3924                       LD    L,[1Y+DIR MAX  LENGTH]                  - GET   ALLOCATED     AMOUNT    OF  DELETED   FILE 
                         3925                       LD    H,[1Y+DIR_MAX_LENGTH+      1]  
                         3926  
                         3927                       LD    DE,[BLOCKS  REQ]               ; MIN   AMOUNT    NEEDED
                         3928  
                         3929                       PUSH  HL                             
                         3930                       OR    &                              ;Clear  carry    flag
                         3931                       SBC   HL,DE                          ; WILL   IT  FIT?
                         3932                       POP   HL                             
                         3933  
                         3934                       JR    C,TOO_SMALL                    ; NOPE,   TRY  ANOTHER    ONE
                         3935  
                         3936                       LD    [BLOCKS  REQ],HL               ; FORCE   ALLOCATED     AMOUNT
                         3937  
                         3938                       CALL  LOAD_NEW_ENTRY_INFO            
                         3939                       '                                    
                         3940                       JP    NZ,MAKE  ERROR                 
                         3941  
                         3942                       JP    TIME_TO_WRITE                  
                         3943  
                         3944  ; COMPARE    FCB_BLOCK   TO  FCB LAST   BLOCK.     GO   TO MORE  BLOCKS
                         3945  ; IF  FCB _LAST  BLOCK   > FCB BLOCK.
                         3946  
                         3947  USE_HOLE:                                                 
                         3948                       LD    A,[ IX+FCB_BLOCK+3]            
                         3949                       CP    [IX+FCB_LAST_BLOCK+3]          
                         3950                       JR    C,MORE  BLOCKS                 
                         3951                       LD    A,[IX*FCB_BLOCK+2]             
                         3952                       CP    [IX+FCB_  LAST  BLOCK+2]       
                         3953                       JR    C,MORE_BLOCKS                  
                         3954                       LD    A,[IX*FCB_BLOCK+    1]         
                         3955                       CP    [IX*FCB_LAST_BLOCK+1]          
                         3956                       JR    C,MORE_BLOCKS                  
                         3957                       LD    A,[IX+FCB_  BLOCK]             
                         3958                       CP    IX*FCB_LAST_BLOCK]             
                         3959                       JR    C,MORE  BLOCKS                 
                         3960  
                         3961  ; FALL   THROUGH   IF THIS   IS  THE  LAST   BLOCK  OF   THE  FILE.
                         3962  
                         3963                       LD    A,B                            ;LOOK   AT ENTRY   COUNTER
                         3964                       CP    1                              
                         3965                       JP    2,TAPE_FULL                    ;ERROR   IF  NO  ENTRIES   LEFT   VACANT
                         3966  
                         3967  MORE                 BLOCKS                                
                         3968                       LD    L,[1Y¥+DIR_MAX_LENGTH]         ;GET  THE  SIZE   OF  THE  HOLE
                         3969                       LD    H,[1¥+DIR_MAX_LENGTH+1]        
                         3970  
                         3971                       BIT   MODE _REMAINOER_BIT,[IX+FCB_       MODE] ; NEED   TO  ALLOCATE    REST   OF TAPE?
                         3972                       JR    2,CHECK_HOLE   SIZE            ; NOPE
                         3973  
                         3974                       LD    AH                             ; YUP,   CHECK   IF  THERE   ARE  ANY  BLOCKS    LEFT
                         3975                       OR    L                              
                         3976                       JP    2,TAPE _FULL                   ; TAPE   FULL
                         3977  
                         3978                       LD    [BLOCKS  REQ],HL               ; NOT   FULL,  REQUEST    REST   OF  TAPE
                         3979                       RES   MODE REMAINDER    BIT,[IX+TFCB    MODE] 
                         3980  
                         3981  CHECK_HOLE           SIZE:                                
                         3982                       LD    DE,[BLOCKS  REQ]               ;GET  THE  REQUESTED    SIZE
                         3983                       OR    A                              
                         3984                       SBC   HL,DE               -COMPARE   THEM 
                         3985                       JP    C,TAPE_FULL                    ;BRANCH   IF  THE  HOLE   IS  TOO  SMALL
                         3986                       LD    [NEW_HOLE_SIZE],HL             ;ELSE  SAVE   THE  RESULT
                         3987  
                         3988  
                         3989  ; ADD BLOCKS  REQ   TO DIR_START    BLOCK    TO  FIND  THE  HOLE‘S    NEW
                         3990  ; START  BLOCK.    NOTICE  HOW   STOOOPID    THE  Z80  IS  WITH   ADDITION!
                         3991                       LD    HL,BLOCKS REQ                  ;POINT    TO THE  NUMBER    TO  ADD
                         3992                       LD    A,[IY¥+DIR_START_BLOCK]        
                         3993                       ADD   A,[HL]                         
                         3994                       INC   HL                             
                         3995                       LD    [NEW_HOLE  START],A            
                         3996                       LD    A,[IV+DIR_START_BLOCK+1]                                                                                                ‘ 
                         3997                       ADC   A,[HL]                         
                         3998                       INC   HL                             
                         3999                       LD    [NEW _HOLE START+1],A          
                         4000                       LD    A,[IY+DIR_START_BLOCK+2]       
                         4001                       ADC   A,[HL]                         
                         4002                       INC   HL                             
                         4003                       LD    [NEW_HOLE  START+2],A          
                         4004                       LD    A,[IY#DIR_START_BLOCK+3]       
                         4005                       ADC   A,[HL]                         
                         4006                       INC   HL                             
                         4007                       LD    [NEW HOLE  START+3],A          
                         4008  
                         4009                       PUSH  BC                             ;SAVE   ENTRY   COUNT   (IN  B)
                         4010  
                         4011                       CALL  LOAD_NEW_ENTRY_INFO            
                         4012  
                         4013                       POP   BC                             ;RESTORE    ENTRY   COUNT
                         4014  
                         4015                       JP    NZ,MAKE  ERROR                 
                         4016  
                         4017                       LD    L,[IX+FCB_POINTER]             ;GET   CURRENT   POINTER
                         4018  
                         4019  
                         4020                       LD    H,[1X+FCB_POINTER+1]           
                         4021                       LD    DE,OIR_ENT_LENGTH              ;GET  LENGTH   OF  AN  ENTRY
                         4022                       ADD   HL,DE                          ;ADVANCE    POINTER   TO  NEXT   ENTRY
                         4023                       LD    [IX+¢FCB_POINTER],L            ;AND   SAVE  IT  AGAIN
                         4024                       LD    [I1X+FCB_POINTER+1],H          
                         4025  
                         4026                       DJNZ  NOT_END                        ;UUMP   IF  THERE  ARE   MORE   ENTRIES
                         4027  
                         4028  ;THIS LABEL  NOT   USED  IN THIS   ROUTINE,    NOT  DECLARED    GLOBAL
                         4029  ;REMOVED  BECAUSE   IT CONFLICTS    WITH   IDENTICAL    LABEL   ELSEWHERE
                         4030  ;WRITE_AGAIN:
                         4031                       LD    A,[IX+FCB_ DEVICE]             ;GET   PARAMETERS    FROM   FCB
                         4032                       LD    HL,[BUF START]                 
                         4033                       LD    E,[1X+FCB_ BLOCK]              
                         4034                       LD    D,[1X+FCB_BLOCK+1]             
                         4035                       LD    C,[1X+FCB_  BLOCK+2]           
                         4036                       LD    B,[1X+FCB_  BLOCK+3]           
                         4037  
                         4038                       CALL  WRITE BLOCK                    
                         4039  
                         4040                       JP    NZ,MAKE_ERROR                  ;NOPE,    A REAL  LIVE    ERROR
                         4041  
                         4042  
                         4043  RESET_THE_POINTER:                                        
                         4044                       LD    HL,[BUF_START]                 ;RESET   THE  POINTER
                         4045                       LD    [IX¢FCB_POINTER],L             
                         4046                       LD    [ IX+FCB_POINTER+1],H          
                         4047  
                         4048                       INC   [IX¢FCB_BLOCK]                 ;INC   BLOCK   -- NO  CARRY  OUT
                         4049  
                         4050  TIMEOUT_IN_READ:                                          
                         4051                       LD    A,[IX+FCB_DEVICE]              ;GET  PARAMETERS    FROM   FCB
                         4052                       LD    L,[ IX+FCB_POINTER]            
                         4053                       LD    H,[IX+FCB_POINTER+1]                                                                                                           ' 
                         4054                       LD    E,[IX+FCB_BLOCK]               
                         4055                       LD    D,[IX+FCB_BLOCK+1]             
                         4056                       LD    C,[ IX+FCB_BLOCK+2]            
                         4057                       LD    B,[IX+FCB_BLOCK+3]             
                         4058                       CALL  READ BLOCK                     ;AND   READ  THE  NEXT  BLOCK
                         4059  
                         4060                       JR    NZ,MAKE_ERROR                  ;  NOPE,  ERRORIIIII!
                         4061  
                         4062  
                         4063                       LD    L,[IX*FCB_POINTER]             ;GET  POINTER    INTO  IY  THE   LONG WAY
                         4064                       LD    H,[IX+FCB_POINTER+1]           
                         4065  
                         4066  NOT_END:                                                  
                         4067                       PUSH  HL                             
                         4068                       POP   IY                  STAT       
                         4069  
                         4070  ;*
                         4071  ;*  STILL  TRYING    TO CALC  THE  NEW   START   ADOR
                         4072  ;=                    .
                         4073                       LD    HL,[NEW_HOLE SIZE]             
                         4074                       LD    [IY+DIR_MAX_LENGTH],L          ;  BLOCKS   LEFT   ON TAPE
                         4075                       LD    [IY+DIR_MAX_LENGTH+1],H        
                         4076  
                         4077                       LD    A,[NEW_HOLE_START]             
                         4078                       LD    [IY+DIR_START_BLOCK],A         
                         4079                       LD    A,[NEW_HOLE_START+1]           
                         4080                       LD    [IY+DIR_START_BLOCK+1],A       
                         4081                       LD    A,[NEW_HOLE_START+2]           
                         4082                       LD    [IY+DIR_START_BLOCK+2],A       
                         4083                       LD    A,[NEW_HOLE_START+3]           
                         4084                       LD    [IY+DIR_START_BLOCK+3],A       
                         4085  
                         4086                       LD    [IY+DIR_ATTR],ATTR_HOLE        ; SET  HOLE   UP
                         4087  
                         4088                       PUSH  IY                             
                         4089                       POP   DE                             
                         4090  
                         4091                       LD    HL,HOLE_FILE_NAME              
                         4092                       LD    BC,12                          
                         4093                       LDIR                                 
                         4094  
                         4095  TIME_TO_WRITE:                                            
                         4096                       LD    A,[IX+FCB  DEVICE]             ;GET PARAMETERS  FROM  FCB
                         4097                       LD    HI,[BUF START]                 
                         4098                       LD    E,[IX+FCB_BLOCK   ]            
                         4099                       LD    0,[1X+FCB_BLOCK+   1]          
                         4100                       LD    C,[1X+FCB_BLOCK+2]             
                         4101                       LD    8B[IX+FCB_BLOCK+3]             
                         4102                       CALL  WRITE  _BLOCK                  ;WRITE  THE BLOCK OUT
                         4103  
                         4104                       JR    NZ,MAKE ERROR                  ; IT’S A BOO BOO! !
                         4105                       XOR   A                              ;SHOW NO  ERROR
                         4106  
                         4107  LETS_GET_OuT:                                             
                         4108  MAKE_ERROR:                                               
                         4109                                                            ;RESTORE  THE REGISTERS
                         4110                       OR    A                                                                                                             ‘ 
                         4111                       POP   BC                             
                         4112                       POP   DE                             
                         4113                       POP   HL                             
                         4114                       POP   IX                             
                         4115                       POP   RY                             
                         4116                       RET                                  
                         4117  
                         4118  TOO_BIG                                                   
                         4119                       LD    A,TOO_BIG_ERR                  ;SHOW AN  ERROR
                         4120                       JR    MAKE_ERROR                     
                         4121  
                         4122  
                         4123  FILE_EXISTS                                               
                         4124                       LD    A,FILE_ EXISTS_ERR             
                         4125                       JR    MAKE_ERROR                     
                         4126  
                         4127  FULL_DIR_EXIT:                                            
                         4128                       LD    A,FULL_DIR_ERR                 
                         4129                       JR    MAKE_ERROR                     
                         4130  
                         4131  TAPE_FULL                                                 
                         4132                       LD    A,FULL_TAPE_ERR                
                         4133                       JR    MAKE_ERROR                     
                         4134  ;«+
                         4135  ;¢
                         4136  ;*    SUBROUTINE   NAME:  GET  FILE   NAME  LENGTH
                         4137  ;*
                         4138  ;«      ENTRY:   HL- POINTS   TO  TEXT  STRING
                         4139  ;*      EXIT:    Z=1=FOUND   AND  PROPER   SIZE  (1-12)
                         4140  ;*                 BC=BYTE   COUNT
                         4141  ;                  A=TRASHED
                         4142  ;*
                         4143  ;*               Z=O=ERROR
                         4144  ;*                 BC=TRASH
                         4145  ;»                 A=FILE  NAME  _TOO LONG
                         4146  ;* DLS(8/28/83)
                         4147  ;*
                         4148  GET_FILE_NM_LEN:                                          
                         4149                       PUSH  HL                             ;SAVE  THE POINTER  TO  FILE NAME
                         4150                       LD    B,12                           ;SCAN  UP TO 12 BYTE
                         4151                       LD    C,1                            ;SET COUNT  TO 1
                         4152  SRCH_LOOP:                                                
                         4153                       LD    A,[HL]                         ;GET FN(1)
                         4154                       CP    03                         SETX 
                         4155                       JR    2,GOT_IT                       
                         4156  ;*
                         4157                       INC   C                              
                         4158                       INC   HL                             ;ADVANCE POINTER  TO FILE  NAME  STRING
                         4159                       DJNZ  SRCH_LOOP                      
                         4160  ;
                         4161  ERR_GFN                                                   
                         4162                       LD    A,FILE_NM_ERR                  
                         4163                       OR    A                              ;SHOW ERROR
                         4164                       POP   HL                             
                         4165                       RET                                  
                         4166  ;*
                         4167  GOT_IT                                                    
                         4168                       LD    A,C                            
                         4169                       CP    1                              ;ETX ALONE  IS NOT VALID
                         4170                       JR    2,ERR_GFN                      
                         4171                       LD    8,0                            
                         4172                       XOR   A                              ;SHOW OK
                         4173                       POP   HL                             
                         4174                       RET                                  
                         4175  
                         4176  
                         4177  
                         4178  
                         4179  LOAD_NEW_ENTRY_INFO:                                      
                         4180                       PUSH  IY                             ;GET   NAME   ADORESS     INTO    DE
                         4181                       POP   DE                             
                         4182  
                         4183                       LD    HL,[USER_    NAME]             ;GET   USER’S    STRING    ADDRESS
                         4184  ;«
                         4185                       CALL                                 ; DLS(8/28/83)
                         4186                       JP    NZ,MAKE  ERR   1               
                         4187  ;*
                         4188                       LDIR                                 ;COPY   USER’S    NAME    INTO   DIR   ENTRY
                         4189  
                         4190                       LD    A,ATTR_USER                    ;SET   THE  DEFAULT     ATTRIBUTE
                         4191                       LD    [1Y+OIR_ATTR],A                
                         4192                       é                                    
                         4193                       LD    BC,[BLOCKS   REQ]              ;GET   NEW   FILE’S    MAX   SIZE
                         4194                       LD    [I¥+DIR_MAX_LENGTH],C          ;PUT   INTO    DIR
                         4195                       LD    [1Y¥*DIR_MAX_LENGTH+1],8       
                         4196  
                         4197  
                         4198                       LD    [1¥+DIR_USED_LENGTH],1         ;INIT   COUNT    OF   BLOCKS    USED
                         4199                       LD    [1¥*DIR_USED_LENGTHT1],0       
                         4200  
                         4201                       LD    [I¥+DIR_LAST_COUNT],O          ;INIT   BYTECOUNT      IN   LAST   BLOCK
                         4202                       LD    [1 ¥*#DIR_LAST_COUNT+1],0      
                         4203  
                         4204                       LD    A,[EOS  YEAR]           >INSERT    THE   DATE 
                         4205                       LD    [IV+DIR_VEAR],A                
                         4206                       LD    A,[EOS  MONTH]                 
                         4207                       LD    [1¥*#DIR_  MONTH],A            
                         4208                       LD    A,[EOS  DAY]                   
                         4209                       LD    [1V¥+DIR_DAY],A                
                         4210  
                         4211  
                         4212  
                         4213  __MAKE_ERR_1:                                             
                         4214                       RET                                  
                         4215  
                         4216  ;
                         4217  ;***********************************************************************************
                         4218  ;***********************************************************************************
                         4219  ;***********************************************************************************
                         4220  ;
                         4221  
                         4222  
                         4223                                                            ;GLB       _OPEN_FILE, _CLOSE_FILE, _RESET_FILE
                         4224                                                            ;EXT       FCB_HEAD_ADDR,FCB_DATA_ADDR
                         4225                                                            ;EXT       BUF START, _FMGR_DIR_ENT
                         4226                                                            ;EXT       __QUERY_FILE,  MODE_CHECK,READ_BLOCK, WRITE_LOCK
                         4227                                                            ;EXT       __SET_FILE
                         4228                                                            ;EXT       FILE_NAME_ADDR
                         4229  
                         4230  ;-----------------------------------------------------------------------------------------
                         4231  ;
                         4232  ;  _OPEN_FILE    --  Sets up an FCB for the caller to access a file.
                         4233  ;
                         4234  ;  CALLING  PARAMETERS: device number in A;   address of name string
                         4235  ;                    in HL;  mode in B.
                         4236  ;
                         4237  ;  EXIT  PARAMETERS:     if no error   --  Z = 1;  A  =  file number                                                                                      '
                         4238  ;                        if error      --  Z = 0;  A  =  error code;    B  =  junk
                         4239  ;
                         4240  ;-----------------------------------------------------------------------------------------
                         4241  
                         4242  ;  NEXT_FCB   CHANGED   TO  O NEXT   _FCB   TO  PREVENT    CONFLICT      WITH
                         4243  ;  IDENTICAL    LABEL  ELSEWHERE
                         4244  
                         4245  _OPEN_FILE                                                
                         4246                       PUSH  IY                             ;SAVE    REGISTERS
                         4247                       PUSH  HL                             
                         4248                       PUSH  IX                             
                         4249                       PUSH  DE                             
                         4250  
                         4251                       PUSH  AF                             ;SAVE   DEVICE     NUMBER
                         4252  EA07                 CS    4282              PUSH      BC ;SAVE   MODE
                         4253  
                         4254  ;  FIRST,  WE  HAVE  TO   LOCATE   A  FREE   FCB.
                         4255  EA08                 DD2AFDFO 4258              LO        IX,[FCB_HEAD_ADOR] ;GET  POINTER     TO   FIRST   FCB’S   HEAD
                         4256                       LD    DE,FCB_LENGTH                  
                         4257                       ADD   IX,DE                          ;  SKIP   OVER   IT   --  BELONGS     TO  SYSTEM
                         4258  
                         4259                       LD    I¥,[FCB_DATA_ADDR]             ;:GET  POINTER     TO   FIRST   FCB’S   BODY
                         4260                       LD    DE,1024                        
                         4261                       ADD   IY,DE                          ;  SKIP   OVER   IT   TOO
                         4262  
                         4263                       LD    BI                             ;SET   FCB   NUMBER
                         4264  O_NEXT_FCB                                                
                         4265                       LD    A,[IX+FCB_   MODE]             ;GET   THE   MODE   BYTE    FROM   FCB
                         4266                       OR    A                              ;CHECK    IT
                         4267                       JR    Z,GOT_ONE                      ;BRANCH     IF  THIS   ONE   IS  FREE
                         4268  
                         4269                       LD    DE,FCB_LENGTH                  ;ELSE     SKIP   OVER    IT
                         4270                       ADD   1X,DE                          
                         4271                       LD    DE,1024                        
                         4272                       ADD   IY,DE                          
                         4273  
                         4274                       INC   8                     -INC   THE   FCB  NUMBER 
                         4275                       LD    A,B                            
                         4276                       CP    NUM FCBS              SARE   THERE    MORE   FCBS   TO  CHECK? 
                         4277                       JR    C,0 NEXT   FCB                 ;LOOP   UNTIL    WE’VE    SEEM   THEM   Ait
                         4278  NO_FCBS              :                                    
                         4279                       POP   BC                    RESTORE      RP    § 
                         4280                       POP   AF                             
                         4281                       POP   DE                             
                         4282                       POP   IX                             
                         4283                       POP   HL                             
                         4284                       POP   IY                             
                         4285  
                         4286                       LD    A,NO_FCB_ERR                   ;SET  THE ERROR CODE
                         4287                       OR    A                              ;SET  THE CONDITIONS
                         4288  EA3D                 C9    4268          RET              
                         4289  
                         4290  GOT_ON                                                    
                         4291                       LD    [BUF_START],IY                 ;SAVE  THE FCB BUFFER’S  ADDRESS
                         4292  
                         4293                       POP   AF                             ;GET THE  MODE
                         4294                       LD    [IX+FCB_MODE],A                ;PUT  IT INTO FCB                                                                       '
                         4295                       POP   AF                             ;GET THE  DEVICE
                         4296                       LD    [IX+FCB_DEVICE],A              ;PUT IT INTO FCB
                         4297  
                         4298                       PUSH  BC                             ;SAVE  THE FCB NUMBER
                         4299  
                         4300                       PUSH  HL                             
                         4301                       POP   DE                             ; ADDRESS  OF NAME STRING
                         4302  
                         4303                       PUSH  IX                             ;POINT  TO FCB NAME (ASSUME  OFFSET  =  0)
                         4304                       POP   HL                             
                         4305                       LD    A,[IX+FCB_DEVICE]              ;GET  DEVICE NUMBER
                         4306                       CALL  __QUERYFILE                    ;GET THE  FILE’S DIR  ENTRY
                         4307                       JP    NZ,OP_ERR                      ;BRANCH  IF THERE WAS  AN ERROR
                         4308                                                            ;#** SET  PARAMS ees
                         4309                       CALL  MODECHECK                      ;SEE IF  MODE MATCHES  ATTRIBUTES
                         4310                       JP    NZ,OP_ERR                      ;BRANCH  IF NOT
                         4311  
                         4312                       LD    A,[IX+FCB_USED_ LENGTH]        ;CALC. & SET  LAST BLOCK
                         4313                       ADD   A,[IX+FCB_FIRST BLOCK]         
                         4314                       LD    [IX+FCB_LAST BLOCK],A          
                         4315                       LD    A,[IX+FCB_FIRST  BLOCK+1]      
                         4316                       ADC   A,[IX+FCB_USED LENGTH+T1]      
                         4317                       LD    [IX+FCB_LAST BLOCK+1],A        
                         4318                       LD    A,[IX+FCB_FIRST BLOCK+2]       
                         4319                       ADC   A,O                            
                         4320                       LD    [IX+FCB_LAST_BLOCK+2],A        
                         4321                       LD    A,[IX+FCB_FIRST_BLOCK+3]       
                         4322                       ADC   A,O                            
                         4323                       LD    [IX+FCB_LAST BLOCK+3],A        
                         4324  
                         4325                       LD    A,[IX+FCBLAST  BLOCK+TO]       
                         4326                       SUB   1                              
                         4327                       LD    [IX+FCB_LAST BLOCK+O],A        
                         4328  
                         4329                       LD    A,[IX+FCB_LAST BLOCK+I]        
                         4330                       SBC   A,O                            
                         4331                       LD    [IX+FCB_LAST BLOCKTI],A        
                         4332  
                         4333                       LD    A,[IX+FCLAST  BLOCK+T2]        
                         4334                       SBC   A,O                            
                         4335                       LB    [I1X+FCBLAST BLOCK+2],A        
                         4336  
                         4337                       LD    A,[IX*FCB_LAST_BLOCK+3]        
                         4338                       SAC   A,O                            
                         4339                       LD    [IX+FCB_LAST  BLOCK+3],A       
                         4340  
                         4341                       LD    DE,[BUF_START]                 ;INIT   BUFFER  POINTER
                         4342                       LD    [IX+FCB_POINTER],E             
                         4343                       LD    [IX+FCB_POINTER+1],0           
                         4344  
                         4345                       LD    A,[IX+FCB_FIRST_  BLOCK]       ;SET  BLOCK   TO FIRST BLOCK
                         4346                       TO    [IX*FCB_BLOCK],A               
                         4347                       LD    A,[IX+FCB_FIRST  BLOCK+1]      
                         4348                       LD    [IX+FCB  BLOCK+1],A            
                         4349                       LD    A,[IX+FCB_FIRST_BLOCK+2]       
                         4350                       LD    [IX+FCB  BLOCK+2],A            
                         4351                       LD    A,[IX*FCB_FIRST_BLOCK+3]                                                                                        : 
                         4352                       LD    [IX+FCB_BLOCK+3],A,            
                         4353  
                         4354                       LD    A,[IX+FCB_MODE]                ;LOOK  AT  THE  MODE
                         4355                       AND   MODE MODE                      
                         4356                       CP    MODE WRITE                     ;IS  IT  WRITE  MODE?
                         4357                       JR    2,OPENS                        ;JUMP   IF SO  --  NO PRE-READ  NECESSARY
                         4358  
                         4359  READ_TIMEOUT:                                             
                         4360  ;*                    Tf FCB_USED  LENGTH    = 1  (file  size  of  one block)
                         4361                       XOR   A                              ;load  Acc with zero
                         4362                       CP    [IX+FCB_USED_LENGTH+   1]              SHIGH  ORDER MUST BE ZERO 
                         4363                       JR    NZ,NOT_SIZE  1                 ;I1f not then past bitset
                         4364                       INC   &                              ;Inc  Acc to a  1
                         4365                       CP    [IX+¢FCB_USED_LENGTH]          ;Compare  with low order
                         4366                       JR    NZ,NOT_SIZE_1                  ;If not  equal then exit
                         4367  
                         4368  ;+                    Then  set  last block   bit  in mode
                         4369                       SET   MODE  LAST  BLOCK BIT,[IX+FCB_MODE] ;Set  it
                         4370  ;+                    Endif
                         4371  NOT_SIZE_1:                                               
                         4372  
                         4373                       LD    A,[IX*FCB_DEVICE]              ;GET  THE  DEVICE   NUMBER
                         4374                       LD    HL,[BUF_ START]                ;GET  BUFFER  ADDRESS
                         4375                       LD    E,[IX+FCB_BLOCK]               ;GET  BLOCK  NUMBER
                         4376                       LD    O,[IX+FCB_BLOCK+   1]          
                         4377                       LD    C,[IX+FCB  BLOCK+2]            
                         4378                       LD    8,[IX+FCB_BLOCK+3]             
                         4379                       CALL  READ_BLOCK                     ;READ  THE  FIRST  BLOCK
                         4380  
